<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Me as a method</title>
	<subtitle>我的想法不是我的，我察觉到了我的想法。</subtitle>
	<link href="http://pypy.info/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="http://pypy.info"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-10-25T00:00:00+00:00</updated>
	<id>http://pypy.info/atom.xml</id>
	<entry xml:lang="en">
		<title>深入理解 Rust - References and Borrowing</title>
		<published>2022-10-25T00:00:00+00:00</published>
		<updated>2022-10-25T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-borrow/" type="text/html"/>
		<id>http://pypy.info/rust-borrow/</id>
		<content type="html">&lt;p&gt;指针是万恶之源。&lt;&#x2F;p&gt;
&lt;p&gt;你不拥有这块数据，你只是有一个指向这块数据的地址（数据引用）。如果数据被删了，被改了，你根本就不知道。换言之，你所依赖的这块数据并不安全。因为你担心别的代码对它动手脚。很多 bug 就是这么出现的，data race, dangling pointer，等等等等。&lt;&#x2F;p&gt;
&lt;p&gt;细想一下，数据的安全性主要由两个因素控制：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;共享性：数据是否共享，是否存在多个引用？&lt;&#x2F;li&gt;
&lt;li&gt;可变性：数据是否允许被修改？&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;换言之，一块数据之所以会不安全，是因为它同时满足了共享性和可变性。有这块数据引用的可能不止一个地方，而且都能修改这块数据，我们就开始担心别的引用会修改这块数据，破坏我的这块代码的假设。&lt;&#x2F;p&gt;
&lt;p&gt;于是，要想得到数据安全，只需要：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;禁止数据共享: 不允许共享数据 (unsharable)&lt;&#x2F;li&gt;
&lt;li&gt;禁止数据可变：不允许修改数据 (immutable)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;禁止数据共享。这个好理解，如果这块数据是你独享的，只有你一个引用，那么别的代码不可能对它动手脚，数据是安全的。&lt;&#x2F;p&gt;
&lt;p&gt;禁止数据可变。是函数式的思路，比如 Haskell，不允许有副作用，要想改就基于旧的创建一个新的，数据手递手传递。这样你依赖一个数据，就可以放心地假设它不会被别人悄悄地修改。比如依赖一个字典，可以肯定这个字典的 key-values 不会被悄悄地改掉。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 保护数据安全的机制就是这两个思路的组合：&lt;strong&gt;如果你要允许一个引用修改数据，那么就不允许创建多个引用 (共享数据）。如果你要创建多个引用 (共享数据)，那么就不允许这些引用修改数据。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;官方文档&lt;&#x2F;a&gt;对这个理念的表达是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;At any given time, you can have either one mutable reference or any number of immutable references.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;（值得注意的是，这是一个静态约束，即编译期就可以检查的保证）&lt;&#x2F;p&gt;
&lt;p&gt;但凡事总有例外。&lt;&#x2F;p&gt;
&lt;p&gt;有些场景下，这个规则是必须得破坏掉的，否则便实现不了所需要的功能。&lt;&#x2F;p&gt;
&lt;p&gt;比如要实现一个共享 &lt;code&gt;cache&lt;&#x2F;code&gt;，程序的多个地方通过引用指向同一个 &lt;code&gt;cache&lt;&#x2F;code&gt; 对象来使用这个 &lt;code&gt;cache&lt;&#x2F;code&gt;。也就是说，共享 &lt;code&gt;cache&lt;&#x2F;code&gt; 的引用可能有多个（否则就称不上共享了）。&lt;&#x2F;p&gt;
&lt;p&gt;而对一个 &lt;code&gt;cache&lt;&#x2F;code&gt; 的主要使用方式，其实就是读和写。先读一下，如果发现 cache miss，那么就去获取这个 miss 的数据，然后写回 cache。也就是说，&lt;code&gt;cache&lt;&#x2F;code&gt; 的引用必须支持修改数据（缓存需要：存）。&lt;&#x2F;p&gt;
&lt;p&gt;在共享 &lt;code&gt;cache&lt;&#x2F;code&gt; 这个场景下，我们既要能共享数据，又要能修改数据。既要共享性，也要可变性。上文提到的规则不适用了。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 提供了另一个机制来处理这种场景。官方说法叫&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-05-interior-mutability.html&quot;&gt;内部可变性(interior-mutability)&lt;&#x2F;a&gt;。其实它的真正意思是：共享可变性(shared-mutability)。&lt;&#x2F;p&gt;
&lt;p&gt;共享可变性在运行期，而不是编译期来保证数据安全。核心做法是使用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;&lt;code&gt;Cell&lt;&#x2F;code&gt; 类型&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;总结一下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Rust 引用有两种：共享性引用(&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;)和可变性引用(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;共享性引用和可变性引用在编译期互斥。要么有一个可变性引用(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;)，要么有任意数量的共享性引用(&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;)，而不能同时有二者存在。&lt;&#x2F;li&gt;
&lt;li&gt;共享性引用可以使用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;&lt;code&gt;Cell&lt;&#x2F;code&gt; 类型&lt;&#x2F;a&gt; 使其在运行时可变，以满足共享且可变的场景。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;后记：&lt;&#x2F;p&gt;
&lt;p&gt;为了加深理解，可变性引用(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;) 可以理解成互斥性引用。它的 &lt;code&gt;mut&lt;&#x2F;code&gt; 其实可以理解为互斥锁 &lt;code&gt;mutex&lt;&#x2F;code&gt; 的 &lt;code&gt;mut&lt;&#x2F;code&gt;，而不是 &lt;code&gt;mutable&lt;&#x2F;code&gt; 的 &lt;code&gt;mut&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;慢慢就会发现，Rust 中的 &lt;code&gt;mut&lt;&#x2F;code&gt; 关键字，基本上就是互斥的意思。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>简明机器学习 - 可微分编程</title>
		<published>2022-10-22T00:00:00+00:00</published>
		<updated>2022-10-22T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/differentiable-programming/" type="text/html"/>
		<id>http://pypy.info/differentiable-programming/</id>
		<content type="html">&lt;p&gt;得到一个程序有两种方式，其一是由程序员来编写它，其二是通过大量数据来拟合它。也就是所谓的编程和机器学习。&lt;&#x2F;p&gt;
&lt;p&gt;当我们在编程的时候，我们是在编写整个程序。当我们在机器学习的时候，我们在编写半个程序，剩下的部分，通过数据来拟合而得。&lt;&#x2F;p&gt;
&lt;p&gt;数据拟合，即通过数据，来反推这个产生这批数据的规律，这个规律相当于代码。&lt;&#x2F;p&gt;
&lt;p&gt;人脑的规则，和数据的规律，融合成一起，成为最终的程序。&lt;&#x2F;p&gt;
&lt;p&gt;现在问题来了，如何通过数据反推规律？&lt;&#x2F;p&gt;
&lt;p&gt;答案就在 “学习” 二字之中。&lt;&#x2F;p&gt;
&lt;p&gt;所谓学习，就是不断尝试，不断犯错，不断调整，直至不出错。&lt;&#x2F;p&gt;
&lt;p&gt;所谓机器学习，就是机器通过不断尝试，不断犯错，不断调整，直至不出错。&lt;&#x2F;p&gt;
&lt;p&gt;这个尝试，反馈，调整的回路，怎么搭建？&lt;&#x2F;p&gt;
&lt;p&gt;对于一个程序，哪些部分需要学习，哪些部分需要硬编码？&lt;&#x2F;p&gt;
&lt;p&gt;让我们从一个常量开始。&lt;&#x2F;p&gt;
&lt;p&gt;比如说，数字 &lt;code&gt;5&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;显然，常量没有任何变化可言，是个硬编码。&lt;&#x2F;p&gt;
&lt;p&gt;现在，我们来让这个常量产生变化的可能性，让它乘以一个变量 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w * 5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大功告成，世界上最简单的机器学习程序写好了。&lt;code&gt;5&lt;&#x2F;code&gt; 是人编写的，&lt;code&gt;w&lt;&#x2F;code&gt; 是未知的，需要通过机器学习而得到。&lt;&#x2F;p&gt;
&lt;p&gt;下一步，我们需要发明一种机制，来不断调整这个 &lt;code&gt;w&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w = w - dw
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;dw&lt;&#x2F;code&gt; 就是 &lt;code&gt;delta w&lt;&#x2F;code&gt;，也就是 &lt;code&gt;w 的变化&lt;&#x2F;code&gt; 的意思。 &lt;code&gt;w = w - dw&lt;&#x2F;code&gt; 就是调整 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;下一步，我们需要确定这个  &lt;code&gt;dw&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;观察我们的程序 &lt;code&gt;w * 5&lt;&#x2F;code&gt;，它的意思是 &lt;code&gt;w&lt;&#x2F;code&gt; 的任何变化，都会被放大 &lt;code&gt;5&lt;&#x2F;code&gt; 倍。&lt;&#x2F;p&gt;
&lt;p&gt;假如我们把输出记为 &lt;code&gt;y&lt;&#x2F;code&gt;，那么 &lt;code&gt;dy = 5 * dw&lt;&#x2F;code&gt;。即：&lt;code&gt;dw = dy &#x2F; 5&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;有了这个关系，当我们知道了 &lt;code&gt;dy&lt;&#x2F;code&gt;, 就等于知道了 &lt;code&gt;dw&lt;&#x2F;code&gt;，就等于知道了新的 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;那么，如何知道 &lt;code&gt;dy&lt;&#x2F;code&gt;？&lt;&#x2F;p&gt;
&lt;p&gt;既然 &lt;code&gt;y&lt;&#x2F;code&gt; 是我们的输出，那么输出的误差，就是 &lt;code&gt;y&lt;&#x2F;code&gt; 需要调整的变化，即 &lt;code&gt;dy&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;dy = y_guess - y_true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;y_true&lt;&#x2F;code&gt; 就是我们的数据（学习源），&lt;code&gt;y_guess&lt;&#x2F;code&gt; 是一次尝试的输出。&lt;code&gt;y_guess = w * 5&lt;&#x2F;code&gt; ，随 &lt;code&gt;w&lt;&#x2F;code&gt; 的变化而变化。&lt;&#x2F;p&gt;
&lt;p&gt;现在只差最后一步，我们就可以跑通这个流程了。这个最后一步是，&lt;code&gt;w&lt;&#x2F;code&gt; 的初始值怎么设置？&lt;&#x2F;p&gt;
&lt;p&gt;答案很简单，给个随机数就好了，反正它会被自动调节。&lt;&#x2F;p&gt;
&lt;p&gt;现在，我们用真实数据测试一下这个流程：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;# --- test 1 ---
&lt;&#x2F;span&gt;&lt;span&gt;y = 15  # 正确答案, 即 w = 3
&lt;&#x2F;span&gt;&lt;span&gt;w = w0 = 2  # 随机初始化 w 为 2
&lt;&#x2F;span&gt;&lt;span&gt;y_guess = w * 5  # 2 * 5 = 10
&lt;&#x2F;span&gt;&lt;span&gt;dy = y_guess - y  # 10 - 15 = -5
&lt;&#x2F;span&gt;&lt;span&gt;dw = 1&#x2F;5 * dy  # 1&#x2F;5 * -5 = -1
&lt;&#x2F;span&gt;&lt;span&gt;w = w - dw  # 2 - (-1) = 3  &amp;lt;-- w = 3, y = 15 成功学习到 w = 3
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# --- test 2 ---
&lt;&#x2F;span&gt;&lt;span&gt;y = 40  # 正确答案, 即 w = 8
&lt;&#x2F;span&gt;&lt;span&gt;w = w0 = 12  # 随机初始化 w 为 12
&lt;&#x2F;span&gt;&lt;span&gt;y_guess = w * 5  # 12 * 5 = 60
&lt;&#x2F;span&gt;&lt;span&gt;dy = y_guess - y  # 60 - 40 = 20
&lt;&#x2F;span&gt;&lt;span&gt;dw = 1&#x2F;5 * dy  # 1&#x2F;5 * 20 = 4
&lt;&#x2F;span&gt;&lt;span&gt;w = w - dw  # 12 - 4 = 8  &amp;lt;-- w = 8, y = 40 成功学习到 w = 8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们从一个特例常量 &lt;code&gt;5&lt;&#x2F;code&gt; 开始，通过 &lt;code&gt;w * 5&lt;&#x2F;code&gt; 来推演这个机器学习的过程。其实把常量换成变量 &lt;code&gt;x&lt;&#x2F;code&gt;，上述的推演同样成立，也就是 &lt;code&gt;y = w * x&lt;&#x2F;code&gt;,  因为 &lt;code&gt;w&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;x&lt;&#x2F;code&gt;倍，所以  &lt;code&gt;dy = dw * x&lt;&#x2F;code&gt;,  &lt;code&gt;dw = 1&#x2F;x * d*y&lt;&#x2F;code&gt;。通过特定的的 &lt;code&gt;(x, y)&lt;&#x2F;code&gt; 数据作为学习源，重复上述步骤，可得到正确的 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;现在，我们研究出了怎么把变量和常量参数化，并且通过数据学习这个参数的技术。接下来我们更进一步：既然常量和变量都可以参数化，那么函数可不可以参数化？如果这个函数也是一个需要学习的函数呢？&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;h(x) = w1 * f(x)  # 参数化函数
&lt;&#x2F;span&gt;&lt;span&gt;f(x) = w2 * x  # 参数化变量
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们能同时学习得到 &lt;code&gt;w1&lt;&#x2F;code&gt; 和 &lt;code&gt;w2&lt;&#x2F;code&gt; 吗？&lt;&#x2F;p&gt;
&lt;p&gt;照着刚才的思路，我们需要先考察 &lt;code&gt;dw1&lt;&#x2F;code&gt; 和 &lt;code&gt;dw2&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;对 &lt;code&gt;dw1&lt;&#x2F;code&gt;, 由 &lt;code&gt;w1 * f(x)&lt;&#x2F;code&gt; 可知 &lt;code&gt;w1&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 倍，所以 &lt;code&gt;d_h(x) =  dw1 * f(x)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;对 &lt;code&gt;dw2&lt;&#x2F;code&gt;, 由 &lt;code&gt;w2 * x&lt;&#x2F;code&gt; 可知 &lt;code&gt;w2&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;x&lt;&#x2F;code&gt; 倍，所以 &lt;code&gt;d_f(x) = dw2 * x&lt;&#x2F;code&gt;； 又由 &lt;code&gt;w1 * f(x)&lt;&#x2F;code&gt; 可知，&lt;code&gt;f(x)&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;w1&lt;&#x2F;code&gt; 倍，所以 &lt;code&gt;d_h(x)  = d_f(x) * w1&lt;&#x2F;code&gt;。合并起来就是: &lt;code&gt;d_h(x) = d_f(x) * w1 = (dw2 * x) * w1&lt;&#x2F;code&gt; ，所以：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;dw1 = d_h(x) &#x2F; f(x) = d_h(x) &#x2F; (w2 * x)
&lt;&#x2F;span&gt;&lt;span&gt;dw2 = d_h(x) &#x2F; w1 &#x2F; x  # 先除以 w1，再除以 x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们按刚才的思路试一下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;--- 数据
&lt;&#x2F;span&gt;&lt;span&gt;设 w1 = 3, w2 = 6, x = 2, 则 f(x) = 6x, h(x) = 3f(x) = 18x
&lt;&#x2F;span&gt;&lt;span&gt;f(2) = 12, h(2) = 36
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 随机初始化 w1, w2
&lt;&#x2F;span&gt;&lt;span&gt;w1 = 1, w2 = 4
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 调整 10 个循环，结果如下：---
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;显然，我们遇到了新问题：无论如何调整， &lt;code&gt;w1&lt;&#x2F;code&gt; 和 &lt;code&gt;w2&lt;&#x2F;code&gt; 只是在不停地来回震荡，无法学习到正确的值。&lt;&#x2F;p&gt;
&lt;p&gt;问题出在哪里？&lt;&#x2F;p&gt;
&lt;p&gt;问题不在于来回震荡，问题在于震荡幅度每次都一样大，使得这个震荡停不下来。一个钟摆来回摇摆，只要摆动幅度逐渐变小，那么它最终就会停下来。&lt;&#x2F;p&gt;
&lt;p&gt;所以灵感来了，让我们把震荡幅度每次都变小一点。从数学上表达：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w = w - dw * learning_rate
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个 &lt;code&gt;learning_rate&lt;&#x2F;code&gt; 原本是 &lt;code&gt;1&lt;&#x2F;code&gt; 被我们忽略掉了，当我们取一个&lt;code&gt;大于 0 小于 1 &lt;&#x2F;code&gt;的值时，震荡的幅度就会越来越小。&lt;&#x2F;p&gt;
&lt;p&gt;现在，取 &lt;code&gt;learning_rate = 0.6&lt;&#x2F;code&gt; 试试：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;--- 数据
&lt;&#x2F;span&gt;&lt;span&gt;设 w1 = 3, w2 = 6, x = 2, 则 f(x) = 6x, h(x) = 3f(x) = 18x
&lt;&#x2F;span&gt;&lt;span&gt;f(2) = 12, h(2) = 36
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 随机初始化 w1, w2
&lt;&#x2F;span&gt;&lt;span&gt;w1 = 1, w2 = 4
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 调整 10 个循环，结果如下：---
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  8.0000, d_hx = -28.0000, dw1:-3.5000, dw2: -14.0000, new w1:  3.1000, new w2:  12.4000
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  76.8800, d_hx =  40.8800, dw1: 1.6484, dw2:  6.5935, new w1:  2.1110, new w2:  8.4439
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  35.6495, d_hx = -0.3505, dw1:-0.0208, dw2: -0.0830, new w1:  2.1234, new w2:  8.4937
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0713, d_hx =  0.0713, dw1: 0.0042, dw2:  0.0168, new w1:  2.1209, new w2:  8.4836
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  35.9858, d_hx = -0.0142, dw1:-0.0008, dw2: -0.0034, new w1:  2.1214, new w2:  8.4856
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0028, d_hx =  0.0028, dw1: 0.0002, dw2:  0.0007, new w1:  2.1213, new w2:  8.4852
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  35.9994, d_hx = -0.0006, dw1:-0.0000, dw2: -0.0001, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0001, d_hx =  0.0001, dw1: 0.0000, dw2:  0.0000, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0000, d_hx = -0.0000, dw1:-0.0000, dw2: -0.0000, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0000, d_hx =  0.0000, dw1: 0.0000, dw2:  0.0000, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;成功了吗？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;d_hx&lt;&#x2F;code&gt; 也就是误差的确逐步降低到 0，可是学到的 &lt;code&gt;w1 = 2.1213, w2 = 8.4853&lt;&#x2F;code&gt; ，而我们正确答案是 &lt;code&gt;w1 = 3, w2 = 6&lt;&#x2F;code&gt;。怎么对不上呢？&lt;&#x2F;p&gt;
&lt;p&gt;细心分析下发现， &lt;code&gt;h(x) = w1 * f(x) = w1 * w2 * x  = (w1 * w2) * x&lt;&#x2F;code&gt; ，我们通过 &lt;code&gt;h(x)&lt;&#x2F;code&gt; 的误差来学习整个函数的表示，学到的是一个整体的结果，也就是 &lt;code&gt;w1 * w2&lt;&#x2F;code&gt;，在正确答案中，&lt;code&gt;w1 * w2  = 3 * 6 = 18&lt;&#x2F;code&gt;， 我们的实验结果：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;w1 * w2 = 2.1213 * 8.4853 = 17.9999 ~= 18&lt;&#x2F;code&gt; 也是对的。&lt;&#x2F;p&gt;
&lt;p&gt;也就是说，我们无意中得到了一个因式分解器，因 &lt;code&gt;w1, w2&lt;&#x2F;code&gt; 的初始值不同，我们学习得到不同的参数，这些参数结果对 &lt;code&gt;h(x)&lt;&#x2F;code&gt; 来说，效果都是一样的。有兴趣可以试试。&lt;&#x2F;p&gt;
&lt;p&gt;现在来总结一下机器学习程序的几个要素：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;参数化，使得学习成为可能&lt;&#x2F;li&gt;
&lt;li&gt;计算输出误差，并且根据输出误差反推参数误差&lt;&#x2F;li&gt;
&lt;li&gt;根据参数误差更新参数&lt;&#x2F;li&gt;
&lt;li&gt;重复 1-3 步&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;目前为止我们的探索集中在第一步参数化。其实对于一个机器学习程序来说，哪些部分需要学习（参数化），哪些部分不需要学习（单纯进行数据变换）应该是很自由的事情，否则就编写不出灵活的程序。对于不需要学习，只是单纯做数据变换的部分，我们只需要保证在反推参数误差时，正确地传递这些误差信息就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;说得有些抽象，下面举个例子。比方说：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;h(x) = f(x) ^ 2
&lt;&#x2F;span&gt;&lt;span&gt;f(x) = w * x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;h(x)&lt;&#x2F;code&gt; 是 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 的平方。在这里 &lt;code&gt;h(x)&lt;&#x2F;code&gt; 只是针对 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 的结果做了一个变换（平方），没有任何需要学习的参数。但是，&lt;code&gt;f(x)&lt;&#x2F;code&gt; 是一个需要学习的函数，里边有参数 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;要学习 &lt;code&gt;w&lt;&#x2F;code&gt;，我们需要知道 &lt;code&gt;dw&lt;&#x2F;code&gt;；要知道 &lt;code&gt;dw&lt;&#x2F;code&gt;，我们需要知道 &lt;code&gt;d_h(x)&lt;&#x2F;code&gt; 和 &lt;code&gt;dw&lt;&#x2F;code&gt; 的关系。&lt;&#x2F;p&gt;
&lt;p&gt;我们先不着急找这个关系，先来分析一个更加基本的问题。假如有一个函数 &lt;code&gt;y = a * b&lt;&#x2F;code&gt;，&lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 均为变量。那么 &lt;code&gt;dy&lt;&#x2F;code&gt; （y 的变化）其实是由 &lt;code&gt;a&lt;&#x2F;code&gt; 的变化 &lt;code&gt;da&lt;&#x2F;code&gt; ，以及 &lt;code&gt;b&lt;&#x2F;code&gt; 的变化 &lt;code&gt;db&lt;&#x2F;code&gt;所组成。因为 &lt;code&gt;y = a * b&lt;&#x2F;code&gt;，所以 &lt;code&gt;da&lt;&#x2F;code&gt; 会被放大 &lt;code&gt;b&lt;&#x2F;code&gt; 倍贡献到 &lt;code&gt;dy&lt;&#x2F;code&gt;，而 &lt;code&gt;db&lt;&#x2F;code&gt; 会被放大 &lt;code&gt;a&lt;&#x2F;code&gt; 倍贡献到 &lt;code&gt;dy&lt;&#x2F;code&gt;，综合起来就是 &lt;code&gt;dy = a * db + b * da&lt;&#x2F;code&gt;。假如 &lt;code&gt;a = b = x&lt;&#x2F;code&gt;，也就是 &lt;code&gt;y = x * x = x ^ 2&lt;&#x2F;code&gt;， 则有 &lt;code&gt;dy = x * dx + x * dx = 2 * x * dx&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;把 &lt;code&gt;x&lt;&#x2F;code&gt; 替换成 &lt;code&gt;f(x)&lt;&#x2F;code&gt;, 所以：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;d_h(x) = 2 * f(x) * d_f(x)
&lt;&#x2F;span&gt;&lt;span&gt;d_f(x) = dw * x
&lt;&#x2F;span&gt;&lt;span&gt;--&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;dw = d_h(x) &#x2F; (2 * f(x)) &#x2F; x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有了这个关系，代入某个用例验证一下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;待学习：
&lt;&#x2F;span&gt;&lt;span&gt;h(x) = f(x) ^ 2
&lt;&#x2F;span&gt;&lt;span&gt;f(x) = w * x
&lt;&#x2F;span&gt;&lt;span&gt;w = 8
&lt;&#x2F;span&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span&gt;初始化：
&lt;&#x2F;span&gt;&lt;span&gt;w = 2  # 随机
&lt;&#x2F;span&gt;&lt;span&gt;learning_rate = 0.4
&lt;&#x2F;span&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span&gt;10 个循环结果：
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 64.0000, out_guess:  4.0000, d_h_x: -60.0000, d_w: -15.0000, w: 17.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 256.0000, out_guess:  1156.0000, d_h_x: 900.0000, d_w: 6.6176, w: 10.3824
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 576.0000, out_guess:  970.1393, d_h_x: 394.1393, d_w: 2.1090, w: 8.2733
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 1024.0000, out_guess:  1095.1677, d_h_x: 71.1677, d_w: 0.2688, w: 8.0045
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 1600.0000, out_guess:  1601.8065, d_h_x: 1.8065, d_w: 0.0045, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 2304.0000, out_guess:  2304.0007, d_h_x: 0.0007, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 3136.0000, out_guess:  3136.0000, d_h_x: 0.0000, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 4096.0000, out_guess:  4096.0000, d_h_x: 0.0000, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 5184.0000, out_guess:  5184.0000, d_h_x: 0.0000, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Python 代码在&lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;py0x&#x2F;1083a81285505af6775a54ef5c5188f0&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;最终成功学习到 &lt;code&gt;w = 8&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以总结一下，机器学习的函数和普通编程下的函数有两个不同点：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;可能&lt;&#x2F;strong&gt;带有待学习的参数 w&lt;&#x2F;li&gt;
&lt;li&gt;除了能够正向计算结果，还需要反向计算误差（为了调整参数）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;只要我们的函数都满足这两点，并且能够这些函数组合起来，就能得到一个能够学习的程序。&lt;&#x2F;p&gt;
&lt;p&gt;下面，我们来研究函数组合的问题。&lt;&#x2F;p&gt;
&lt;p&gt;最简单的组合方式是：一个函数的输出是另一个函数的输入。这种情况我们已经通过上文的 &lt;code&gt;h(x)&lt;&#x2F;code&gt;  和 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 无意中研究过。&lt;&#x2F;p&gt;
&lt;p&gt;在编程视角下，更基本的组合方式是 &lt;code&gt;if ... else ...&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;问题是这种逻辑控制语句，怎么计算和传播误差？&lt;&#x2F;p&gt;
&lt;p&gt;首先，我们需要把它表示出来。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;if p(x):
&lt;&#x2F;span&gt;&lt;span&gt;    return f(x)
&lt;&#x2F;span&gt;&lt;span&gt;else:
&lt;&#x2F;span&gt;&lt;span&gt;    return h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后进行数学化。&lt;&#x2F;p&gt;
&lt;p&gt;非此即彼的 &lt;code&gt;if else&lt;&#x2F;code&gt;，在数学上，其实是 1 和 0.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;1 * f(x) + 0 * h(x)&lt;&#x2F;code&gt; 就是 &lt;code&gt;f(x)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;0 * f(x) + 1 * h(x)&lt;&#x2F;code&gt; 就是 &lt;code&gt;h(x)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这个 &lt;code&gt;1&lt;&#x2F;code&gt; 和 &lt;code&gt;0&lt;&#x2F;code&gt; 的逻辑关系需要学习出来，其实就是变成参数：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w1 * f(x) + w2 * h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来的问题是，&lt;code&gt;p(x)&lt;&#x2F;code&gt; 怎么和它们关联起来？&lt;&#x2F;p&gt;
&lt;p&gt;其实细细想一下，这个 &lt;code&gt;w1&lt;&#x2F;code&gt; 和 &lt;code&gt;w2&lt;&#x2F;code&gt; 正是 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出结果。而且 &lt;code&gt;w2 = 1 - w1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;于是我们只要保证 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出范围在 &lt;code&gt;0 ~ 1&lt;&#x2F;code&gt;，那么有：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w = p(x)
&lt;&#x2F;span&gt;&lt;span&gt;output = w * f(x) + (1 - w) * h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里需要注意的是，&lt;code&gt;w&lt;&#x2F;code&gt; 并不是直接学习得到的参数，而是 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出结果，我们并不是直接学习 &lt;code&gt;w&lt;&#x2F;code&gt;，而是学习一个 &lt;code&gt;p(x)&lt;&#x2F;code&gt; ，也就是学习 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 内部的参数。为了不容易混淆，我把它换成 &lt;code&gt;k&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;k = p(x)
&lt;&#x2F;span&gt;&lt;span&gt;output = k * f(x) + (1 - k) * h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大功接近告成。剩下的问题是怎么保证 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出落在 0 至 1 之间。&lt;&#x2F;p&gt;
&lt;p&gt;很简单，套上一个值域在 0 至 1 之间的变换函数即可。&lt;&#x2F;p&gt;
&lt;p&gt;这种函数有很多，比如可以自己构造一个 &lt;code&gt;1 &#x2F; (1 + f(x) ^ 2)&lt;&#x2F;code&gt;。(这个函数的误差怎么反向传播，可以自己试试）&lt;&#x2F;p&gt;
&lt;p&gt;至此，我们有了可以学习的 &lt;code&gt;if ... else ...&lt;&#x2F;code&gt; 控制语句。&lt;&#x2F;p&gt;
&lt;p&gt;有了这个思路，其实查字典也可以数学化表示。&lt;&#x2F;p&gt;
&lt;p&gt;一个字典，其实是 &lt;code&gt;{k, v}&lt;&#x2F;code&gt; 容器，查字典就是有一个 &lt;code&gt;q&lt;&#x2F;code&gt;, 当 &lt;code&gt;q == k&lt;&#x2F;code&gt; 时，返回对应的 &lt;code&gt;v&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在机器学习的世界里，&lt;code&gt;(q, k, v)&lt;&#x2F;code&gt; 都是数字。&lt;&#x2F;p&gt;
&lt;p&gt;判断 &lt;code&gt;q == k&lt;&#x2F;code&gt; 的操作，表达为 &lt;code&gt;q&lt;&#x2F;code&gt; 和 &lt;code&gt;k&lt;&#x2F;code&gt; 的差别，比如说 &lt;code&gt;q - k&lt;&#x2F;code&gt; 的大小。于是有：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;d1 = q - k1
&lt;&#x2F;span&gt;&lt;span&gt;d2 = q - k2
&lt;&#x2F;span&gt;&lt;span&gt;d3 = q - k3
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后把 &lt;code&gt;d1, d2, d3 ...&lt;&#x2F;code&gt; 进行归一化操作。再把归一化后的结果作为权重 &lt;code&gt;w&lt;&#x2F;code&gt;，去提取 &lt;code&gt;v&lt;&#x2F;code&gt;，也就是 &lt;code&gt;(1-w) * v&lt;&#x2F;code&gt; (需要用 &lt;code&gt;1 - w&lt;&#x2F;code&gt; 是因为差异越小，提取权重越大）。&lt;&#x2F;p&gt;
&lt;p&gt;归一化比较简单的方式是: &lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w1 = d1 &#x2F; (d1 + d2 + d3 + ... + dn)
&lt;&#x2F;span&gt;&lt;span&gt;w2 = d2 &#x2F; (d1 + d2 + d3 + ... + dn)
&lt;&#x2F;span&gt;&lt;span&gt;w3 = d3 &#x2F; (d1 + d2 + d3 + ... + dn)
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们现在可以总结一下：&lt;&#x2F;p&gt;
&lt;p&gt;要使得一个程序能够变成机器学习程序，思路是把所有的操作变成数学公式表达，这个数学公式需要能够反向计算出误差是怎么传播的。&lt;&#x2F;p&gt;
&lt;p&gt;范式如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;输入输出数据转换成数字&lt;&#x2F;li&gt;
&lt;li&gt;控制操作转换成数学公式&lt;&#x2F;li&gt;
&lt;li&gt;正向计算结果和误差&lt;&#x2F;li&gt;
&lt;li&gt;反向根据误差更新参数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在机器学习的世界中，一个操作既能正向计算结果，也能反向传播误差并更新参数。当我们把常用的操作封装起来，然后提供一些能组合这些操作的胶水操作，用户就可以像搭积木一样利用我们提供的操作原语 (primitive) 来搭建一个可以学习的程序，这个程序因为参数是未知的，而架构是已知的，所以叫模型。这个行为就是所谓的机器学习建模。&lt;&#x2F;p&gt;
&lt;p&gt;搭建好的模型，通过大量灌入数据，调整模型参数，就是所谓机器学习训练。&lt;&#x2F;p&gt;
&lt;p&gt;而本文提到的这种编程范式，有一个正式的名字，叫可微分编程。可微分，指的是这个数学操作可微，使得误差可以反向传播，从而使程序可以自我学习。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;后记：&lt;&#x2F;p&gt;
&lt;p&gt;关于机器学习，这个领域网上有大量优秀的文章和教程，也有很多的细分领域和专业的术语。&lt;&#x2F;p&gt;
&lt;p&gt;我尝试补充一个更基础、直观且具有启发性的角度。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>简明 Rust 指南 - 理解 Rust Ownership 机制</title>
		<published>2022-09-24T00:00:00+00:00</published>
		<updated>2022-09-24T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-ownership/" type="text/html"/>
		<id>http://pypy.info/rust-ownership/</id>
		<content type="html">&lt;p&gt;每个编程语言都有自己管理内存的方式。因为内存有限，原则是数据在使用的时候加载到内存，不需要使用的时候及时释放，避免内存被撑爆。&lt;&#x2F;p&gt;
&lt;p&gt;较底层的语言比如 &lt;code&gt;C&lt;&#x2F;code&gt;  ，需要程序员手动管理内存。也就是手动申请内存，手动释放内存。&lt;&#x2F;p&gt;
&lt;p&gt;较高级的语言比如 &lt;code&gt;Python&lt;&#x2F;code&gt; ，有所谓垃圾回收机制，无需用户手动管理内存，大为减轻程序员心智负担。&lt;&#x2F;p&gt;
&lt;p&gt;而 &lt;code&gt;Rust&lt;&#x2F;code&gt; 比较独特，采用了一种叫 &lt;code&gt;Ownership&lt;&#x2F;code&gt; 的机制来管理内存。可以认为是一种半自动的内存管理方式。&lt;&#x2F;p&gt;
&lt;p&gt;据说有不少程序员在理解 &lt;code&gt;Ownership&lt;&#x2F;code&gt; 机制时会遇到困难，其中不乏经验丰富的程序员。&lt;&#x2F;p&gt;
&lt;p&gt;经验告诉我们，理解新事物出现困难，往往是成见太深。也就是说只要放轻松，回归到事情的原点来看待问题，就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;假如现在要实现一个自动管理内存的机制，比较自然的思路是看看这块内存有谁在使用，如果没有被使用，则表明这块内存可以被回收以便再次使用。这个思路大家称之为&lt;code&gt;引用计数法&lt;&#x2F;code&gt;，即当引用数为 0 时，可回收内存。比如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Data&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;b = a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此时，对数据 &lt;code&gt;Data()&lt;&#x2F;code&gt; 所占用的内存，有 &lt;code&gt;2&lt;&#x2F;code&gt; 个引用，分别是 &lt;code&gt;a&lt;&#x2F;code&gt;  和 &lt;code&gt;b&lt;&#x2F;code&gt;  。当 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 这两个变量退出作用域，那么数据 &lt;code&gt;Data&lt;&#x2F;code&gt; 所占用的内存引用数为 &lt;code&gt;0&lt;&#x2F;code&gt;，可以在恰当的时候被回收。(所谓变量退出作用域，大意是变量所在的作用域 (scope) 被关闭，比如函数返回)。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;引用计数&lt;&#x2F;code&gt;这种行为会给程序带来额外的开销，因为运行时 (runtime) 需要一直去追踪每份数据到底有多少引用，并且对引用数为 0 的数据定时执行释放。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 的思路是既然引用计数会带来额外开销，那就干脆不计数了。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用数永远为 1，可不可以？&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;回到刚才的例子，&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Data&lt;&#x2F;span&gt;&lt;span&gt;()  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 引用数 = 1 ，引用为 a 
&lt;&#x2F;span&gt;&lt;span&gt;b = a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 引用数 = 1 ，引用为 b， 且 a 不再合法 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在 &lt;code&gt;b = a&lt;&#x2F;code&gt; 之后，&lt;code&gt;a&lt;&#x2F;code&gt; 不能再使用，因为引用数只能为 1，且对 &lt;code&gt;Data()&lt;&#x2F;code&gt; 的引用变成了 &lt;code&gt;b&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;直观一点来看这个规则，&lt;code&gt;Data()&lt;&#x2F;code&gt; 就像有了一个 &lt;code&gt;owner&lt;&#x2F;code&gt; 一样，&lt;code&gt;a = Data()&lt;&#x2F;code&gt; 时，&lt;code&gt;owner&lt;&#x2F;code&gt; 是 &lt;code&gt;a&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;b = a&lt;&#x2F;code&gt; 后，&lt;code&gt;owner&lt;&#x2F;code&gt; 从 &lt;code&gt;a&lt;&#x2F;code&gt; 变成了 &lt;code&gt;b&lt;&#x2F;code&gt;，就像 &lt;code&gt;Data()&lt;&#x2F;code&gt; 从 &lt;code&gt;a&lt;&#x2F;code&gt; 转移 (move) 到了 &lt;code&gt;b&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;有了这个规则之后，内存回收就变得简单了，当 &lt;code&gt;owner&lt;&#x2F;code&gt; 退出作用域时 (scope 关闭)，就可以回收内存。&lt;&#x2F;p&gt;
&lt;p&gt;我认为，在写 &lt;code&gt;Rust&lt;&#x2F;code&gt; 程序的时候，保持一种&lt;strong&gt;数据在不同的变量之间移来移去&lt;&#x2F;strong&gt;的感觉是非常有帮助的。&lt;&#x2F;p&gt;
&lt;p&gt;然而，问题还没完全解决。现实是复杂的，某些情况下，引用数就是需要有多个，不可能为 1。&lt;&#x2F;p&gt;
&lt;p&gt;怎么办？&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用计数啊！&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 的意思是，只有在需要的时候，才使用引用计数。&lt;code&gt;Rust&lt;&#x2F;code&gt; 提供了 &lt;code&gt;Rc&lt;&#x2F;code&gt; 和 &lt;code&gt;Arc&lt;&#x2F;code&gt; 两种 wrapper 来启用引用计数功能 (&lt;code&gt;Arc&lt;&#x2F;code&gt; 是线程安全版本的 &lt;code&gt;Rc&lt;&#x2F;code&gt;)。上面的例子可以写为:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a = Rc::new(Data::new());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b = a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这时候，当 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 都不再使用时，&lt;code&gt;Data&lt;&#x2F;code&gt; 才会被销毁。&lt;&#x2F;p&gt;
&lt;p&gt;引用计数的使用场景在并发共享数据的情况下极为常见，比如要开 &lt;code&gt;n&lt;&#x2F;code&gt; 个线程同时访问同一份数据，这时候便需要用 &lt;code&gt;Arc&lt;&#x2F;code&gt; 把数据包装起来，然后 &lt;code&gt;.clone()&lt;&#x2F;code&gt;  &lt;code&gt;n&lt;&#x2F;code&gt; 次得到 &lt;code&gt;n&lt;&#x2F;code&gt; 个 owner，再 move 到线程里边使用。大概的模式如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; n = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data = Arc::new(Data::new());  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;开启引用计数
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..n {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data_x = data.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 先 clone 一个 owner
&lt;&#x2F;span&gt;&lt;span&gt;    thread::spawn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;do_something&lt;&#x2F;span&gt;&lt;span&gt;(data_x);  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 将 data_x move 到线程内使用 
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有了 &lt;code&gt;Rc&lt;&#x2F;code&gt; 和 &lt;code&gt;Arc&lt;&#x2F;code&gt;， 问题似乎得到了完美的解决。&lt;&#x2F;p&gt;
&lt;p&gt;但是，这样做似乎很麻烦。因为多引用是一个极为常见的情况。有没有别的办法？&lt;&#x2F;p&gt;
&lt;p&gt;引用计数，引用计数。能不能只引用，不计数？&lt;&#x2F;p&gt;
&lt;p&gt;关键就在这里。引用之所以需要计数，是因为引用的新增和销毁行为是动态的，也就是说需要把程序跑起来才能知道，所以才需要一个动态的计数器来追踪这个动态的行为。&lt;&#x2F;p&gt;
&lt;p&gt;反过来，如果引用的新增和销毁行为是静态的，也就是编译期就能知道，那么就不需要计数了。&lt;&#x2F;p&gt;
&lt;p&gt;比如有数据引用 a，此后从 a 衍生出新引用 &amp;amp;a，且静态分析得知 &amp;amp;a 使用并销毁在 a 销毁之前，那么数据就可以只增加引用而不增加计数，因为从内存回收的角度，这个 &amp;amp;a 的引用实际上就像没出现过一样。&lt;&#x2F;p&gt;
&lt;p&gt;也就是说，编译时确保 &amp;amp;a 的生命周期在 a 的生命周期以内，那么运行时只需要在 a 销毁的时候回收内存即可。&lt;&#x2F;p&gt;
&lt;p&gt;直观感受一下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;textile&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-textile &quot;&gt;&lt;code class=&quot;language-textile&quot; data-lang=&quot;textile&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    a = Data()
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        b = &amp;amp;a  &#x2F;&#x2F; &amp;amp;a started
&lt;&#x2F;span&gt;&lt;span&gt;        ... do something ...
&lt;&#x2F;span&gt;&lt;span&gt;    }  &#x2F;&#x2F; &amp;amp;a ended
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这就是 &lt;code&gt;Rust&lt;&#x2F;code&gt; 所谓的 &lt;code&gt;Borrow&lt;&#x2F;code&gt; 和 &lt;code&gt;Lifetime&lt;&#x2F;code&gt; 的概念。&lt;&#x2F;p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;Borrow&lt;&#x2F;code&gt; 和 &lt;code&gt;Lifetime&lt;&#x2F;code&gt; 需要依赖编译期的静态分析，所以往往适用于顺序执行的情况。而在并发执行时，因为往往不知道哪个并发单元先执行完，需要使用动态的 &lt;code&gt;Arc&lt;&#x2F;code&gt; 来进行引用计数。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;总结：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ownership&lt;&#x2F;code&gt; 机制是一种特殊的引用计数内存管理机制，计数永远为 1 。在写 &lt;code&gt;Rust&lt;&#x2F;code&gt; 程序的时候，保持一种&lt;strong&gt;数据在不同的变量之间移来移去&lt;&#x2F;strong&gt;的感觉是非常有帮助的.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 同样支持常规的引用计数内存管理机制，&lt;code&gt;Rc&#x2F;Arc&lt;&#x2F;code&gt;。在并发编程的时候经常会用到。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;此外，&lt;code&gt;Rust&lt;&#x2F;code&gt; 支持只增加引用不增加计数的机制，也就是 &lt;code&gt;Borrow&lt;&#x2F;code&gt;。这种机制需要依赖编译期的静态分析，以确保 &lt;code&gt;Lifetime&lt;&#x2F;code&gt; 的合法。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;严谨的细节和规范看文档就可以，带着上面的思路多写写，很容易找到感觉。&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>

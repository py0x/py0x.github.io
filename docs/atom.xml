<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Me as a method</title>
	<subtitle>用直觉与逻辑寻求好解释，用好解释丰富直觉与逻辑</subtitle>
	<link href="http://pypy.info/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="http://pypy.info"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2023-01-07T00:00:00+00:00</updated>
	<id>http://pypy.info/atom.xml</id>
	<entry xml:lang="en">
		<title>深入 Rust - Rust 中最重要的事</title>
		<published>2023-01-07T00:00:00+00:00</published>
		<updated>2023-01-07T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-most-important/" type="text/html"/>
		<id>http://pypy.info/rust-most-important/</id>
		<content type="html">&lt;h3 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h3&gt;
&lt;p&gt;编程时，我们实际上需要同时关注 &amp;quot;内存&amp;quot; 和 &amp;quot;数据&amp;quot; 两个概念。&lt;&#x2F;p&gt;
&lt;p&gt;大部分高级语言因为有 &amp;quot;垃圾回收&amp;quot;，所以可以不关注 &amp;quot;内存&amp;quot;，只关心 &amp;quot;数据&amp;quot;。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 没有 &amp;quot;垃圾回收&amp;quot; ，但是它又不希望用户&lt;strong&gt;显式&lt;&#x2F;strong&gt;地去管理内存，它把内存的生命周期和数据的生命周期紧密地结合在一起 (参考: &lt;a href=&quot;https:&#x2F;&#x2F;tourofrust.com&#x2F;44_en.html&quot;&gt;RAII&lt;&#x2F;a&gt;)。&lt;&#x2F;p&gt;
&lt;p&gt;于是，在编写 Rust 代码的时候，我们看似在操作 &amp;quot;数据&amp;quot;，事实上我们在同时操作 &amp;quot;内存&amp;quot; 和 &amp;quot;数据&amp;quot;。&lt;&#x2F;p&gt;
&lt;p&gt;于是，变量(variable)， 不再是其它语言里的变量。&lt;&#x2F;p&gt;
&lt;p&gt;于是，赋值(&lt;code&gt;a = b&lt;&#x2F;code&gt;)，也不再是其它语言里的赋值。&lt;&#x2F;p&gt;
&lt;p&gt;每一句 Rust 代码(expression&#x2F;statement)，都有着更加丰富的语义。&lt;&#x2F;p&gt;
&lt;p&gt;我们带着别的高级语言的经验和直觉，来编写 Rust 代码的时候，就等同于和编译器搏斗。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;&quot;&gt;The Rust Programming Language&lt;&#x2F;a&gt; 为了方便大家入门，使用了一些如 owner&#x2F;borrowing 的隐喻性概念。&lt;&#x2F;p&gt;
&lt;p&gt;但我们最终还是得抛弃掉这些隐喻，去如实地，结合每一个 expression&#x2F;statement 去理解，Rust 编译器的工作原理是什么。
(所有的秘密都藏在 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;introduction.html&quot;&gt;The Rust Reference&lt;&#x2F;a&gt; 里)&lt;&#x2F;p&gt;
&lt;p&gt;下面，我要开始讲述最基础，最重要，又最容易被大家忽略的部分。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nei-cun-he-shu-ju-biao-shi-place-value&quot;&gt;内存和数据表示: Place &amp;amp; Value&lt;&#x2F;h3&gt;
&lt;p&gt;Rust 中最重要的两个概念，分别是 &lt;strong&gt;Place&lt;&#x2F;strong&gt; 和 &lt;strong&gt;Value&lt;&#x2F;strong&gt;，分别和上文提到的 &amp;quot;内存&amp;quot; 和 &amp;quot;数据&amp;quot; 相关。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Place&lt;&#x2F;strong&gt; : 表示内存 &lt;strong&gt;位置&lt;&#x2F;strong&gt; (memory location)。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Value&lt;&#x2F;strong&gt; : 表示 Place (内存位置) 里的 &lt;strong&gt;值&lt;&#x2F;strong&gt; 。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;其中， &lt;strong&gt;Value&lt;&#x2F;strong&gt; 是很简单的，代表实际的值。如:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;1, true, &amp;quot;aaa&amp;quot;, String::new(&amp;quot;hi&amp;quot;), Struct{...}, ...&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Place&lt;&#x2F;strong&gt; 是重点中的重点，却又往往被大家忽略。&lt;&#x2F;p&gt;
&lt;p&gt;我们先来问一个问题:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个变量 (variable), 表达的是一个 Place, 还是一个 Value？&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;考察下面这两行代码:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b = a;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意变量 &lt;code&gt;a&lt;&#x2F;code&gt;，&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;当它出现在等号左边的时候，它表示一个 &lt;strong&gt;Place&lt;&#x2F;strong&gt;，可以存入 1 这个 Value；&lt;&#x2F;li&gt;
&lt;li&gt;当它出现在等号右边的时候，它表示这个 &lt;strong&gt;Place 里的 Value&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;也就是说，一个变量，表示的是一个 Place (place expression)。&lt;&#x2F;p&gt;
&lt;p&gt;但它的&lt;strong&gt;具体表达要结合它的上下文 (context) 来进行&lt;&#x2F;strong&gt;。
在等号左边 (place context)，它就表达为一个 Place；在等号右边 (value context)，它则表达为 Place 里的 Value。&lt;&#x2F;p&gt;
&lt;p&gt;官方说法：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Expressions are divided into two main categories: place expressions and value expressions;
Within each expression, operands may likewise occur in either place context or value context.
The evaluation of an expression depends both on its own category and the context it occurs within.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;具体细节请参考: &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;expressions.html#place-expressions-and-value-expressions&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;place-de-yin-yong-reference&quot;&gt;Place 的引用: Reference&lt;&#x2F;h3&gt;
&lt;p&gt;Place 的使用一般有两种方式：直接表示 和 间接引用。&lt;&#x2F;p&gt;
&lt;p&gt;直接表示，即硬编码，比如变量 (&lt;code&gt;a&lt;&#x2F;code&gt;)，字段 (&lt;code&gt;expr.f&lt;&#x2F;code&gt;), 数组索引 (&lt;code&gt;expr[i]&lt;&#x2F;code&gt;) 和解引用 (&lt;code&gt;*expr&lt;&#x2F;code&gt;)，它们都是 Place。&lt;&#x2F;p&gt;
&lt;p&gt;间接引用，即 Reference，&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过 ref(&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;) 获取一个 Place 的 Reference，作为 Value 使用:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;place -&amp;gt; reference&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过 deref(&lt;code&gt;*&lt;&#x2F;code&gt;) 解引用一个 Reference，得到一个 Place:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*reference -&amp;gt; place&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;(特别注意：受其它语言影响，(&lt;code&gt;*&lt;&#x2F;code&gt;)操作经常被误解，它并&lt;strong&gt;不表示取出&lt;&#x2F;strong&gt; Place 里的值，它表示的是 Place 本身 (Reference 所指向的 Place)，和其它的 Place (如变量）完全等价。
这个 Place 到底表达为 Place, 还是 Place 里的值，则取决于 Context。但是无论如何，它都不表示&lt;strong&gt;取出&lt;&#x2F;strong&gt;。
如果报了 move 有关的错误，那一定是因为用了表达移动&#x2F;取出的操作 (&lt;code&gt;= *p&lt;&#x2F;code&gt;) 或者 (&lt;code&gt;return *p&lt;&#x2F;code&gt;) 等。
(&lt;code&gt;*p&lt;&#x2F;code&gt;) 本身不会报错，因为可以这样 (&lt;code&gt;= &amp;amp;*p&lt;&#x2F;code&gt;)： 先(&lt;code&gt;*&lt;&#x2F;code&gt;)定位 Place，再(&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;)变成 Reference，再移动(&lt;code&gt;=&lt;&#x2F;code&gt;) Reference，而不报错。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;place-de-dong-tai-yin-yong-smart-pointer&quot;&gt;Place 的动态引用: Smart Pointer&lt;&#x2F;h3&gt;
&lt;p&gt;Place 的引用分两种，静态引用 Reference 和 动态引用 Smart Pointer。&lt;&#x2F;p&gt;
&lt;p&gt;所谓动态引用，意思是：&lt;&#x2F;p&gt;
&lt;p&gt;真实的 Place 可能不是固定的，可能一直在变，因此它的 Reference 也一直在变。为了使用这个动态的 Place，我们需要一个静态的 Place 作为入口代理。
Rust 提供一种机制，&lt;a href=&quot;https:&#x2F;&#x2F;web.mit.edu&#x2F;rust-lang_v1.25&#x2F;arch&#x2F;amd64_ubuntu1404&#x2F;share&#x2F;doc&#x2F;rust&#x2F;html&#x2F;book&#x2F;first-edition&#x2F;deref-coercions.html&quot;&gt;暗中&lt;&#x2F;a&gt;
给我们的两个 Place 进行 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ops&#x2F;trait.Deref.html&quot;&gt;动态映射&lt;&#x2F;a&gt;。于是我们使用这个代理 Place 的时候，就像使用真正的 Place 一样。&lt;&#x2F;p&gt;
&lt;p&gt;由于存在一层代理封装，我们便可以封装额外的功能，因此变得 Smart 了起来。因为动态，所以 Smart。&lt;&#x2F;p&gt;
&lt;p&gt;但我们为什么需要动态的内存(Place)映射？&lt;&#x2F;p&gt;
&lt;p&gt;因为我们需要封装动态的内存管理。如 &lt;code&gt;String&lt;&#x2F;code&gt;, &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; 可以随着数据增多动态扩展内存。尽管在它们的内部，内存(Place)是变化的，但在外部我们感知不到，因为代理入口是不变的。&lt;&#x2F;p&gt;
&lt;p&gt;要实现一个 Smart Pointer, 需要实现两个 Traits: &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ops&#x2F;trait.Deref.html&quot;&gt;Deref&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ops&#x2F;trait.Drop.html&quot;&gt;Drop&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Deref 用来实现动态内存映射: &lt;code&gt;fn(&amp;amp;p) -&amp;gt; &amp;amp;p_x&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;(注：Place 的动态映射只能通过其 Reference 映射来表示: &amp;amp;a -&amp;gt; &amp;amp;b, 因为 Place 在函数签名里(value context)会表达为 Place 里的值）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Drop 用来销毁内部动态申请的内存&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;著名的 Smart Pointer 如: &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; 其实是做了 Stack Place 到 Heap Place 的动态映射。在 Stack Place 退出作用域时，通过 Drop 销毁 Heap Place。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;value-zai-place-zhi-jian-de-liu-dong-yi-dong-move-fu-zhi-copy-clone-yin-yong-reference&quot;&gt;Value 在 Place 之间的流动: 移动(Move), 复制(Copy, Clone), 引用(Reference)&lt;&#x2F;h3&gt;
&lt;p&gt;这里要重点说一下 Rust 的赋值 (&lt;code&gt;=&lt;&#x2F;code&gt;) 符号。和其它语言建立起来的直觉不同，它不是数学意义上的等于。&lt;strong&gt;它意味着 Value 在 Place 之间流动&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;广义地，有 4 种基本流动方式 (以 &lt;code&gt;let a = b&lt;&#x2F;code&gt; 为例):&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Copy.html&quot;&gt;Copy&lt;&#x2F;a&gt;:
复制 b 的 Value 到 a。复制的方式是 bitwise copy，只对一些基本的简单类型生效。Copy 之后 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 里都有一份数据。无需显式调用。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;clone&#x2F;index.html&quot;&gt;Clone&lt;&#x2F;a&gt;:
复制 b 的 Value 到 a。复制的方式是定制化的复制。需要 b 的类型实现 Clone trait，通过 &lt;code&gt;let a = b.clone()&lt;&#x2F;code&gt; 来使用。&lt;code&gt;.clone()&lt;&#x2F;code&gt; 之后 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 里都有一份数据。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;rust-by-example&#x2F;scope&#x2F;move.html&quot;&gt;Move&lt;&#x2F;a&gt;:
移动 b 的 Value 到 a。移动之后 b 没有数据，不能再使用。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.reference.html&quot;&gt;Reference&lt;&#x2F;a&gt;:
&lt;code&gt;let a = &amp;amp;b&lt;&#x2F;code&gt;。有些时候不能 Copy，不能&#x2F;不需要 Clone，也没办法 Move，这时候往往可以取引用。（比如遍历一个链表，&lt;code&gt;node = &amp;amp;node.next&lt;&#x2F;code&gt;)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;除了赋值 (&lt;code&gt;let a = b&lt;&#x2F;code&gt;), &lt;strong&gt;Value 在 Place 之间流动&lt;&#x2F;strong&gt; 还会发生在函数调用 (&lt;code&gt;foo(x)&lt;&#x2F;code&gt;) ，返回 (&lt;code&gt;return x&lt;&#x2F;code&gt;), 创建 struct (&lt;code&gt;Struct{a: b}&lt;&#x2F;code&gt;) 等场景。&lt;&#x2F;p&gt;
&lt;p&gt;我们要考虑这 4 种基本流动方式。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;place-de-fang-wen-yu-an-quan&quot;&gt;Place 的访问与安全&lt;&#x2F;h3&gt;
&lt;p&gt;基本原则就是&lt;strong&gt;读写锁访问原则&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Place 的共享性与可变性互斥。共享不可变，可变不共享。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;另外值得注意的是，这个原则是需要递归成立的。&lt;&#x2F;p&gt;
&lt;p&gt;比如 a 是共享的 (&amp;amp;)，a 里边的 b 是可变的 (&amp;amp;mut)，通过 a 入口去访问 b (&lt;code&gt;a.b&lt;&#x2F;code&gt;)，那么 &lt;code&gt;a.b&lt;&#x2F;code&gt; 实际上是共享的，所以不可变。
但如果 a 是独享的(owner本身或者 &amp;amp;mut), 那么 &lt;code&gt;a.b&lt;&#x2F;code&gt; 则可变。&lt;&#x2F;p&gt;
&lt;p&gt;更多参考：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;&#x2F;rust-borrow&quot;&gt;深入 Rust - References and Borrowing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;&#x2F;rust-shared-mutability&quot;&gt;深入 Rust - 共享可变性&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;place-de-sheng-ming-zhou-qi&quot;&gt;Place 的生命周期&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;Place 退出作用域时，会（递归地）调用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;ops&#x2F;trait.Drop.html&quot;&gt;Drop&lt;&#x2F;a&gt; 释放所有关联资源。&lt;&#x2F;li&gt;
&lt;li&gt;Place 的引用 (Reference) 的生命周期不能大于 Place 的生命周期。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>深入 Rust - 异步编程内幕</title>
		<published>2022-11-05T00:00:00+00:00</published>
		<updated>2022-11-05T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-async/" type="text/html"/>
		<id>http://pypy.info/rust-async/</id>
		<content type="html">&lt;h2 id=&quot;han-shu&quot;&gt;函数&lt;&#x2F;h2&gt;
&lt;p&gt;让我们从函数说起。&lt;&#x2F;p&gt;
&lt;p&gt;一个普通函数，我们调用它的时候，它会执行完成并返回最终结果。&lt;&#x2F;p&gt;
&lt;p&gt;一个异步函数，我们调用它的时候，或许它会执行完成返回最终结果: &lt;code&gt;Ready(result)&lt;&#x2F;code&gt;，又或许它没能执行完成，返回一个需要等待的&amp;quot;标志&amp;quot;: &lt;code&gt;Pending&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;为了使得异步函数执行完成，我们需要（隔一段时间就）反复调用它，直到拿到最终结果。&lt;&#x2F;p&gt;
&lt;p&gt;问题是，为什么会出现这种函数？&lt;&#x2F;p&gt;
&lt;p&gt;答案是: Non-Blocking I&#x2F;O&lt;&#x2F;p&gt;
&lt;h2 id=&quot;non-blocking-i-o&quot;&gt;Non-Blocking I&#x2F;O&lt;&#x2F;h2&gt;
&lt;p&gt;程序调用链的尽头是系统调用。&lt;&#x2F;p&gt;
&lt;p&gt;系统调用默认是阻塞 (Blocking) 的，也就是程序卡在那里等内核返回。&lt;&#x2F;p&gt;
&lt;p&gt;正常情况下阻塞调用不会有太大问题，但对网络 I&#x2F;O 操作而言，因为涉及到和外部系统交互且传输时延大，这种阻塞调用会导致 CPU 闲置。&lt;&#x2F;p&gt;
&lt;p&gt;于是可以采用非阻塞 (Non-Blocking) 的方式，这时候 I&#x2F;O 操作可能拿到结果，也可能返回错误（未 ready），但不会卡住。&lt;&#x2F;p&gt;
&lt;p&gt;如果 I&#x2F;O 操作返回了&amp;quot;未 Ready&amp;quot;。那么程序可以继续去干一些别的计算，过一段时间再来尝试 I&#x2F;O 操作。&lt;&#x2F;p&gt;
&lt;p&gt;这个 Non-Blocking I&#x2F;O 的调用，就是异步函数的原型。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-bu-han-shu-future&quot;&gt;异步函数 Future&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;jie-kou-interface&quot;&gt;接口 (interface)&lt;&#x2F;h3&gt;
&lt;p&gt;一个最底层的函数往往是因为要进行 Non-blocking IO 而被 &amp;quot;传染&amp;quot; 成异步函数。 它的函数接口可以写成如下的样子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span&gt;(...) -&amp;gt; Poll;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;Poll&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Ready(T),
&lt;&#x2F;span&gt;&lt;span&gt;    Pending,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;把它命名为 poll, 是因为这个函数可以被反复调用（轮训），直到 &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 的语境下，异步函数被命名为 &lt;code&gt;Future&lt;&#x2F;code&gt;: 这个 poll 函数被设计成一个 &lt;code&gt;Future&lt;&#x2F;code&gt; Trait。&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures&#x2F;latest&#x2F;futures&#x2F;future&#x2F;trait.Future.html&quot;&gt;文档参考&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zu-he-composition&quot;&gt;组合 (composition)&lt;&#x2F;h3&gt;
&lt;p&gt;如上文所说，一个最底层函数因为 Non-blocking I&#x2F;O 而被 &amp;quot;传染&amp;quot; 成使用异步接口。&lt;&#x2F;p&gt;
&lt;p&gt;这种传染还会继续发生，调用异步函数的函数，只能是异步函数。因为向下调用的异步函数可能会返回 Pending，这时候只能向上返回 Pending。&lt;&#x2F;p&gt;
&lt;p&gt;我们考虑一个普通函数组合 (字母代表不同的函数调用，函数 A 的结果是由函数 B 和 函数 C 的结果相加而得)：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;A = B + C
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果 B 和 C 双方或者任意一方是异步函数，那么只能改成：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;A.poll = B.poll + C.poll  &#x2F;&#x2F; B 和 C 都是异步函数
&lt;&#x2F;span&gt;&lt;span&gt;或
&lt;&#x2F;span&gt;&lt;span&gt;A.poll = B.poll + C  &#x2F;&#x2F; 只有 B 是异步函数
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果我们把这里的 &lt;code&gt;.poll&lt;&#x2F;code&gt; 换一个更恰当的名字: &lt;code&gt;.await&lt;&#x2F;code&gt;，则有：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;A.await = B.await + C.await
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为了区别普通函数和异步函数，我们给异步函数在定义时使用 &lt;code&gt;async&lt;&#x2F;code&gt; 关键字，调用时使用 &lt;code&gt;await&lt;&#x2F;code&gt; 关键字，则有:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;async A = B.await + C.await
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这就是 &lt;code&gt;async&#x2F;await&lt;&#x2F;code&gt; 的原型了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;Future Trait: 最底层通过实现一个 poll 方法，提供基本的 future (叶子 Future)；&lt;&#x2F;li&gt;
&lt;li&gt;Async&#x2F;Await: 上层通过层层组合 future，产生新的 future。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;async-runtime&quot;&gt;Async Runtime&lt;&#x2F;h2&gt;
&lt;p&gt;上文提到 &lt;code&gt;Future.await&lt;&#x2F;code&gt; 会返回 &lt;code&gt;Pending&lt;&#x2F;code&gt;。返回 &lt;code&gt;Pending&lt;&#x2F;code&gt; 是为了不卡住。而不卡住是为了可以执行别的 Future，最大化利用 CPU。&lt;&#x2F;p&gt;
&lt;p&gt;也就是说这里出现了一个 Future 调度执行的需求，一旦某个 &lt;code&gt;Future.await&lt;&#x2F;code&gt; 返回了 &lt;code&gt;Pending&lt;&#x2F;code&gt;, 那么就把它挂起，改为执行别的 Future，等合适的时候，再回头执行之前挂起的 Future。&lt;&#x2F;p&gt;
&lt;p&gt;我们管这个调度执行 Futures 的组件叫 &lt;code&gt;Async Runtime&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Async Runtime&lt;&#x2F;code&gt; 反复切换 Future，反复执行 Future, 直到 Future 拿到最终结果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;runtime-she-ji-si-lu&quot;&gt;Runtime 设计思路&lt;&#x2F;h3&gt;
&lt;p&gt;Async Runtime 的主要功能是调度执行 Futures。于是调度策略变得非常重要。&lt;&#x2F;p&gt;
&lt;p&gt;调度策略主要要解决如下问题：&lt;&#x2F;p&gt;
&lt;p&gt;上文提到，Future 在执行的时候会返回 Pending 而被挂起。那么，这些挂起的 Futures 什么时候应该被再次执行？&lt;&#x2F;p&gt;
&lt;p&gt;如果简单地轮训盲试，有效性可能会很差，白白浪费 CPU 资源。&lt;&#x2F;p&gt;
&lt;p&gt;最好的方式，当然是想办法告诉 Runtime 某个 Future ready 了，应该被再次 poll。&lt;&#x2F;p&gt;
&lt;p&gt;这个办法是有的，为了区别起见，我们把 Async Runtime 分成两个部分：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Executor: 负责调度执行 Futures&lt;&#x2F;li&gt;
&lt;li&gt;Reactor: 负责通知 Executor 某个 Future ready 了&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;reactor&quot;&gt;Reactor&lt;&#x2F;h3&gt;
&lt;p&gt;Reactor 的责任是通知 Executor 某个 Future ready 了，那么 Reactor 怎么知道 Future ready 的？&lt;&#x2F;p&gt;
&lt;p&gt;答案是：操作系统告诉它的。&lt;&#x2F;p&gt;
&lt;p&gt;不严谨地说，Reactor 的原型是 &lt;a href=&quot;https:&#x2F;&#x2F;notes.shichao.io&#x2F;unp&#x2F;ch6&#x2F;#chapter-6-io-multiplexing-the-select-and-poll-functions&quot;&gt;I&#x2F;O Multiplexing&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;所谓 I&#x2F;O Multiplexing 就是用一个专用的线程，去阻塞等待多个 I&#x2F;O sources (比如 socket)。&lt;&#x2F;p&gt;
&lt;p&gt;当有 I&#x2F;O sources 可以进行 I&#x2F;O 操作时，通知和这个 I&#x2F;O source 有关的 handler 进行 I&#x2F;O 操作 (Demultiplexing)。&lt;&#x2F;p&gt;
&lt;p&gt;不同的操作系统提供了不同的系统调用来做这件事，现在一般使用的是 epoll&#x2F;kqueue&#x2F;IOCP。 （可参考 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;mio&quot;&gt;Mio&lt;&#x2F;a&gt; 的实现）&lt;&#x2F;p&gt;
&lt;p&gt;上文提到，Future 的最底层操作往往是 Non-blocking I&#x2F;O，I&#x2F;O 操作意味着有一个 I&#x2F;O source (比如 socket)，
这个 I&#x2F;O source 可以通过 I&#x2F;O Multiplexing 让另一个线程去监听，当它 ready 时，就可以通知 Executor 唤醒和它有关联的 Futures。&lt;&#x2F;p&gt;
&lt;p&gt;换言之，程序的尽头是一堆 I&#x2F;O sources，每个 I&#x2F;O source 其实是和一组 Futures 所关联的。我们通过 Multiplexing 的方式监听 I&#x2F;O sources 的状态，就可以准确地唤醒和它关联的 Futures。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;runtime-jia-gou&quot;&gt;Runtime 架构&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;http:&#x2F;&#x2F;pypy.info&#x2F;rust-async&#x2F;.&#x2F;rust-async.png&quot; alt=&quot;future-runtime&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Executor 调用 future.poll, 并传入一个 callback（注：这个 callback 也叫 Waker，是通过 Future 层层传递最终注册到 Reactor 让它唤醒 Future 的）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;Future(最底层的叶子 Future) 使用 non-blocking 模式对 I&#x2F;O source 操作，直到它返回 err 表示无法继续。&lt;&#x2F;li&gt;
&lt;li&gt;把这个 I&#x2F;O source 和 callback 注册到 Reactor 进行监听 (以便知道什么时候可以继续)。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Reactor 通过操作系统集中监听多个 I&#x2F;O sources。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;I&#x2F;O 事件到达 I&#x2F;O source&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Reactor 调用 callback(Waker) 唤醒对应 Future。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;jie-yu&quot;&gt;结语&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 异步是基于 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;future&#x2F;trait.Future.html&quot;&gt;Future Trait&lt;&#x2F;a&gt; 标准的生态系统。具体实现是多元化的，比如有不同的异步运行时实现。&lt;&#x2F;p&gt;
&lt;p&gt;这里希望提供一些启发性的理解角度，具体的细节请参考其他文档。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>深入 Rust - 共享可变性</title>
		<published>2022-11-01T00:00:00+00:00</published>
		<updated>2022-11-01T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-shared-mutability/" type="text/html"/>
		<id>http://pypy.info/rust-shared-mutability/</id>
		<content type="html">&lt;p&gt;Rust 的 reference 存在一条铁律：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;At any given time, you can have either one mutable reference or any number of immutable references.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;翻译成中文就是：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;共享不可变，可变不共享。共享与可变性互斥。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这条铁律带给了我们安全，同时也给我们带来了限制。&lt;&#x2F;p&gt;
&lt;p&gt;试想，要实现 Graph 这种数据结构怎么办呢？一个 Node 可能被多个其它的 Node 所引用（共享），难道就不能修改这个 Node 的数据了吗（可变）？&lt;&#x2F;p&gt;
&lt;p&gt;站在其他语言的角度，这是很荒谬的。&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是，这个安全性约束是编译期的限制，当我们需要共享可变性时，需要放弃编译期的限制，而改用运行期的检查来保证数据安全。&lt;&#x2F;p&gt;
&lt;p&gt;基本思路有 3 个：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;内部可变性: &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;自建索引: &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;野生指针: Raw pointers&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;1-nei-bu-ke-bian-xing-rc-refcell-t&quot;&gt;1. 内部可变性: &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;这个思路是标准答案，参考官方文档: &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;Interior Mutability 内部可变性&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;原理就是内层使用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;struct.UnsafeCell.html&quot;&gt;UnsafeCell 类型&lt;&#x2F;a&gt; 来封装数据, 而 &lt;code&gt;UnsafeCell&lt;&#x2F;code&gt; 使用 &lt;code&gt;raw pointers&lt;&#x2F;code&gt; 和 &lt;code&gt;unsafe&lt;&#x2F;code&gt; 来绕过编译器限制。&lt;&#x2F;p&gt;
&lt;p&gt;基于 UnsafeCell 类型，标准库封装出一系列的 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;index.html&quot;&gt;Cell 类型&lt;&#x2F;a&gt;，用户不需要直接和 &lt;code&gt;unsafe&lt;&#x2F;code&gt; 及 &lt;code&gt;raw pointers&lt;&#x2F;code&gt; 打交道，而改为调用 &lt;code&gt;Cell 类型&lt;&#x2F;code&gt; 的 API。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 是内部可变性的一个典型例子。用引用计数 &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; 来实现共享，用 Cell 类型 &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; 来实现可变。&lt;&#x2F;p&gt;
&lt;p&gt;之所以说这个例子典型，是因为共享的时候，ownership 往往也是很模糊的，所以使用 Rc 计数。(注：&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 的线程安全版本是 &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;Interior Mutability&lt;&#x2F;a&gt; 的核心在于使用 &lt;code&gt;Cell 类型&lt;&#x2F;code&gt;。我们可以使用各种各样的 wrapper 封装 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;cell&#x2F;index.html&quot;&gt;Cell 类型&lt;&#x2F;a&gt; 实现共享可变。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-zi-jian-suo-yin-hashmap-k-v&quot;&gt;2. 自建索引: &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;这个思路其实更自然, 但没那么直接。&lt;&#x2F;p&gt;
&lt;p&gt;试想，共享不可变其实是 Rust 针对 references 的限制。那么我们不用 references 就好了。&lt;&#x2F;p&gt;
&lt;p&gt;潜台词是：要引用一个对象，不是一定要用 &lt;code&gt;reference(&amp;amp;)&lt;&#x2F;code&gt; 的。&lt;code&gt;key-value&lt;&#x2F;code&gt; 的 &lt;code&gt;key&lt;&#x2F;code&gt; 不也是一种引用么？共享 &lt;code&gt;key&lt;&#x2F;code&gt; 可是没有限制。&lt;&#x2F;p&gt;
&lt;p&gt;原理就是让一个可以索引的容器来存放(own)这些数据，然后用索引来访问它们。&lt;&#x2F;p&gt;
&lt;p&gt;所以不仅仅是 &lt;code&gt;HashMap&lt;&#x2F;code&gt;, &lt;code&gt;Vector&lt;&#x2F;code&gt; 也是可以的，有索引 (index) 的都可以。&lt;&#x2F;p&gt;
&lt;p&gt;而且 Ownership 的问题也通过中心化的容器解决了，容器 own 所有数据。&lt;&#x2F;p&gt;
&lt;p&gt;这种方式，在实现 Graph 这种数据结构的时候是很舒服的。把节点和边都存放到容器，然后通过 index 来互相指向。避免了在有环的情况下，使用引用计数会出现内存泄露的问题。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-ye-sheng-zhi-zhen-raw-pointers&quot;&gt;3. 野生指针: Raw pointers&lt;&#x2F;h3&gt;
&lt;p&gt;这不算一个思路了。强行绕开，注意安全便是。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;基本原则：共享不可变，可变不共享&lt;&#x2F;li&gt;
&lt;li&gt;要想共享且可变，可以 &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 或 &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>实战 Rust - 从零编写 JSON Parser</title>
		<published>2022-10-30T00:00:00+00:00</published>
		<updated>2022-10-30T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-parser-combinator/" type="text/html"/>
		<id>http://pypy.info/rust-parser-combinator/</id>
		<content type="html">&lt;h3 id=&quot;show-you-the-code&quot;&gt;Show you the code&lt;&#x2F;h3&gt;
&lt;p&gt;古语有云，Talk is cheap. 在进行 cheap talk 之前，先放上代码。&lt;&#x2F;p&gt;
&lt;p&gt;实现分两层，1. 通用 Parser Combinator 库 parcomb，2. 基于 parcomb 实现的 JSON parser。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;py0x&#x2F;parcomb&#x2F;blob&#x2F;main&#x2F;examples&#x2F;json.rs&quot;&gt;JSON Parser 实现 (基于 parcomb)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;py0x&#x2F;parcomb&quot;&gt;parcomb 完整代码&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;si-lu&quot;&gt;思路&lt;&#x2F;h3&gt;
&lt;p&gt;写 Parser 是熟悉一门编程语言很好的方式。虽说 Parsing 的技术林林总总，其实不需要太在意，我们可以从简单开始。&lt;&#x2F;p&gt;
&lt;p&gt;一个 Parser 实则上是一个模式识别器 (Pattern Matching), 通过匹配输入数据中的模式，若匹配成功，返回一个值。&lt;&#x2F;p&gt;
&lt;p&gt;最常见的 Parser 莫过于正则表达式 (Regex)。正则表达式的问题在于它只能识别线性的模式，换言之，它无法递归地进行模式识别。&lt;&#x2F;p&gt;
&lt;p&gt;所以正则表达式一般用来匹配一些非结构化的字符串。一旦遇到结构化的字符串，比如 JSON 或程序语言，就无能为力了。&lt;&#x2F;p&gt;
&lt;p&gt;JSON 是个递归嵌套结构，意思是它允许字典套字典，字典套数组，数组又套字典，等等。&lt;&#x2F;p&gt;
&lt;p&gt;要识别这种递归结构的字符串，我们需要一个支持递归地识别的 Parser。这种 Parser 叫递归下降 (recursive descent) Parser。&lt;&#x2F;p&gt;
&lt;p&gt;Parser 叫什么并不重要。我们的重点在于 &lt;strong&gt;递归&lt;&#x2F;strong&gt; 二字。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-gui&quot;&gt;递归&lt;&#x2F;h3&gt;
&lt;p&gt;递归，是一种自然界的规则。它的意思有两层，1. 循环，2. 相似。自然界中大部分东西都符合递归法则，也就是分形，比如树和叶，山和石。&lt;&#x2F;p&gt;
&lt;p&gt;有了递归，我们完全不需要 for&#x2F;while 这种循环控制语句，就可以构造循环。只需要函数反复调用自己并更新调用参数即可。&lt;&#x2F;p&gt;
&lt;p&gt;如果我们把 Parser 表达为一个函数，那么只要在 Parser 里调用其它的 Parser，就能实现支持递归地识别的 Parser。&lt;&#x2F;p&gt;
&lt;p&gt;这意味着，我们的 Parser 完全可以通过组合其它的 Parser 得到。形如：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ParserA = ParserB + ParserC
&lt;&#x2F;span&gt;&lt;span&gt;ParserD = ParserE - ParserF
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这也意味着，我们会有：1. 基本的 Parser,  2. Parser 胶水（基于基本 Parser 组合出复杂 Parser）&lt;&#x2F;p&gt;
&lt;p&gt;这个 2. Parser 胶水， 正式名字叫 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parser_combinator&quot;&gt;Parser Combinator&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;理论就是这么简单，有意思的是用 Rust 去实现这些理论。&lt;&#x2F;p&gt;
&lt;p&gt;因为 Rust 独特的语言特性，使得这个实现有了更多的乐趣。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-xian-he-she-ji&quot;&gt;实现和设计&lt;&#x2F;h3&gt;
&lt;p&gt;我们先来定义 Parser。&lt;&#x2F;p&gt;
&lt;p&gt;函数式的想法是最自然的：&lt;strong&gt;一个 Parser 就是一个函数&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;而 Parser Combinator，所谓的胶水，无非就是一种高阶函数：&lt;strong&gt;接受 Parser 作为输入，返回 Parser 作为输出（接受函数，返回函数）&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;下一步，我们只需要把 Parser 的函数签名(function signature) 固定下来，不同类型的 Parsers 就可以通过胶水自由组合，最终组合成一个具有特定业务目的的 Parser。&lt;&#x2F;p&gt;
&lt;p&gt;而在 Rust 的语境下，我们不首先考虑函数作为抽象单元。我们用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch10-02-traits.html&quot;&gt;Traits(接口)&lt;&#x2F;a&gt; 做高层抽象。也就是说：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Parser 就是一个 Trait&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;然后定义这个 Parser Trait 的行为和输入输出，如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub type &lt;&#x2F;span&gt;&lt;span&gt;ParseResult&amp;lt;I, O, E&amp;gt; = Result&amp;lt;(O, I), E&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Parser&amp;lt;I, O, E&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    I: ?Sized,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; I) -&amp;gt; ParseResult&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;a&lt;&#x2F;span&gt;&lt;span&gt; I, O, E&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;parse&lt;&#x2F;code&gt; 方法接受一个输入 &lt;code&gt;&amp;amp;I&lt;&#x2F;code&gt;，若成功，则返回结果 &lt;code&gt;O&lt;&#x2F;code&gt; 及剩下未用完的 &lt;code&gt;&amp;amp;I&lt;&#x2F;code&gt;，若出错，返回 &lt;code&gt;E&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是，这几个 &lt;code&gt;I&lt;&#x2F;code&gt;, &lt;code&gt;O&lt;&#x2F;code&gt;, &lt;code&gt;E&lt;&#x2F;code&gt; 都是泛型 (Generic Types)。这意味着我们可以为这个 Parser Trait 提供各种各样的具体实现，去支持 str，bytes 等各种各样的 parse 需求。&lt;&#x2F;p&gt;
&lt;p&gt;中间接口层一定，剩下的事情就好办了：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;往上走，&lt;strong&gt;使用这个接口&lt;&#x2F;strong&gt;, 实现高层逻辑，即：基于这个 Parser 接口去实现各种 Parser Combinators；&lt;&#x2F;li&gt;
&lt;li&gt;往下走，&lt;strong&gt;实现这个接口&lt;&#x2F;strong&gt;, 提供底层逻辑，即：为各种各样的具体的类型去实现这个 Parser 接口。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;也就是&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Dependency_inversion_principle&quot;&gt;依赖反转原则 Dependency inversion principle&lt;&#x2F;a&gt; 的应用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xiang-shang-shi-xian-parser-combinator&quot;&gt;向上实现：Parser Combinator&lt;&#x2F;h3&gt;
&lt;p&gt;对 Parser Combinator 的实现，我们首要考虑的是提供哪些胶水操作 (primitives)。&lt;&#x2F;p&gt;
&lt;p&gt;正则表达式其实已经提供了很好的思路，&lt;code&gt;and&lt;&#x2F;code&gt;, &lt;code&gt;or&lt;&#x2F;code&gt;, &lt;code&gt;*&lt;&#x2F;code&gt;, &lt;code&gt;+&lt;&#x2F;code&gt; &lt;code&gt;!&lt;&#x2F;code&gt;, &lt;code&gt;?&lt;&#x2F;code&gt; ...&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;and&lt;&#x2F;code&gt; 操作: &lt;code&gt;p1 and p2&lt;&#x2F;code&gt;，就是先使用 &lt;code&gt;p1&lt;&#x2F;code&gt; 来 parse，若成功，则使用 &lt;code&gt;p2&lt;&#x2F;code&gt; 来 parse，然后返回结果 &lt;code&gt;(o1, o2)&lt;&#x2F;code&gt; ;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;or&lt;&#x2F;code&gt; 操作：&lt;code&gt;p1 or p1&lt;&#x2F;code&gt;，就是先尝试使用 &lt;code&gt;p1&lt;&#x2F;code&gt; 来 parse，若失败，则继续尝试 &lt;code&gt;p2&lt;&#x2F;code&gt; ;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;*&lt;&#x2F;code&gt; 操作：&lt;code&gt;p1*&lt;&#x2F;code&gt;, 就是连续使用 &lt;code&gt;p1&lt;&#x2F;code&gt; 来 parse 0 次到多次，直到失败。&lt;&#x2F;li&gt;
&lt;li&gt;...&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;剩下的我就不一一列举了，可以参考 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parsing_expression_grammar&quot;&gt;PEG(Parsing Expression Grammar)&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;PEG&lt;&#x2F;code&gt; 和 &lt;code&gt;Regex&lt;&#x2F;code&gt; 很像，区别在于 &lt;code&gt;Regex&lt;&#x2F;code&gt; 的基本元素是字符，组合的是字符，不能递归，而 &lt;code&gt;PEG&lt;&#x2F;code&gt; 的基本元素是 Parser，组合的是 Parser，可以递归。&lt;&#x2F;p&gt;
&lt;p&gt;我们实现的话，不用太照本宣科，抓住关键，然后实现一些自己需要的操作即可。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;parcomb&lt;&#x2F;code&gt; 的这些胶水操作，每个操作我都选择了用一个特定的类型 &lt;code&gt;Struct&lt;&#x2F;code&gt; 去表示和实现，然后为每个 &lt;code&gt;Struct&lt;&#x2F;code&gt;  都实现 Parser 这个 Trait，这样所有操作就满足了&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Closure_(mathematics)&quot;&gt;闭包性质&lt;&#x2F;a&gt;，可以自由组合了。&lt;&#x2F;p&gt;
&lt;p&gt;代码见: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;py0x&#x2F;parcomb&#x2F;blob&#x2F;main&#x2F;src&#x2F;parser.rs&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这个实现过程其实有不少有意思地方。比如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Parser Combinator 是选择静态地组合 Parser (impl Trait)，还是动态地组合 Parser (dyn Trait)？&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Rust 支持为所有符合条件的函数&#x2F;闭包自动实现 Parser Trait，方便使用。&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;py0x&#x2F;parcomb&#x2F;blob&#x2F;main&#x2F;src&#x2F;parser.rs#L111&quot;&gt;参考这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Accept interfaces, return structs&lt;&#x2F;strong&gt; 原则的再体会 (其实这个是当初写 Go 语言时学习到的一个原则)。因为 Rust 的类型系统和抽象特性更强大，这个原则对 Rust 甚至更加实用：This suggests that it makes sense to make the argument types of a function as general as possible and the return types as specific as possible。&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;golang&#x2F;comments&#x2F;dfe1qr&#x2F;who_first_said_accept_interfaces_and_return&#x2F;&quot;&gt;参考这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;...&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;实现一次 Parser Combinator，即可对 Rust 的核心语言特性 (Trait, Generic Type) 有很好的感觉。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;xiang-xia-shi-xian-string-parser&quot;&gt;向下实现：String Parser&lt;&#x2F;h3&gt;
&lt;p&gt;我们的 Parser Trait 接口并没有规定输入类型是什么，这意味着可以按需实现接受各种各样输入的 Parser。如接受：&lt;code&gt;str&lt;&#x2F;code&gt;, &lt;code&gt;[u8]&lt;&#x2F;code&gt;, ... 的 Parser。&lt;&#x2F;p&gt;
&lt;p&gt;因为我的目标是一个 JSON Parser，所以我优先实现接受 &lt;code&gt;str&lt;&#x2F;code&gt; 为输入的 basic parsers。代码见: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;py0x&#x2F;parcomb&#x2F;blob&#x2F;main&#x2F;src&#x2F;string_parser.rs&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;所谓的 basic parsers，其实就是方便用户构造 parser 的一些函数，有了这些构造函数，用户就无需从头开始裸写 parser。&lt;&#x2F;p&gt;
&lt;p&gt;比如 literal parser &lt;code&gt;lit&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; par = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;lit&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 生成一个 parse &amp;quot;hello&amp;quot; 的 parser
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; inp = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello world&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; res = par.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;(inp).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!((format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;hello&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;), &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt; world&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;), res);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;甚至可以更通用一些，正则表达式 parser &lt;code&gt;reg&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; par = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;reg&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;\d{2}\w+&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 生成一个 parse r&amp;quot;\d{2}\w+&amp;quot; 这个正则表达式的 parser
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; inp = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;19abcd$$&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; res = par.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;parse&lt;&#x2F;span&gt;&lt;span&gt;(inp).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!((format!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;19abcd&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;), &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;$$&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;), res);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里有意思的是，我们只要用 Parser Combinator 把这些 reg parsers 组合起来，就得到了一个支持递归的正则表达式引擎。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;json-parser&quot;&gt;JSON Parser&lt;&#x2F;h3&gt;
&lt;p&gt;对着 JSON 的 &lt;a href=&quot;https:&#x2F;&#x2F;www.json.org&#x2F;json-en.html&quot;&gt;Schema&lt;&#x2F;a&gt;，使用我们预设好的 String Parser 和 Parser Combinator，就可以描述性地定义出一个 JSON Parser。代码参见：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;py0x&#x2F;parcomb&#x2F;blob&#x2F;main&#x2F;examples&#x2F;json.rs&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这个 JSON Parser 的定义，其实也就 100 行代码左右。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jie-yu&quot;&gt;结语&lt;&#x2F;h3&gt;
&lt;p&gt;能够熟练地使用 Traits 和 Generic Data Types 进行程序设计和实现，应该就能够 Thinking in Rust 了吧。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>简明 Rust - References and Borrowing</title>
		<published>2022-10-25T00:00:00+00:00</published>
		<updated>2022-10-25T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-borrow/" type="text/html"/>
		<id>http://pypy.info/rust-borrow/</id>
		<content type="html">&lt;p&gt;指针是万恶之源。&lt;&#x2F;p&gt;
&lt;p&gt;你不拥有这块数据，你只是有一个指向这块数据的地址（数据引用）。如果数据被删了，被改了，你根本就不知道。换言之，你所依赖的这块数据并不安全。因为你担心别的代码对它动手脚。很多 bug 就是这么出现的，data race, dangling pointer，诸如此类。&lt;&#x2F;p&gt;
&lt;p&gt;细想一下，数据的安全性主要由两个因素控制：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;共享性: 数据是否共享，是否存在多个引用？&lt;&#x2F;li&gt;
&lt;li&gt;可变性: 数据是否允许被修改？&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;换言之，一块数据之所以会不安全，是因为它同时满足了共享性和可变性。有这块数据引用的可能不止一个地方，而且都能修改这块数据，我们就开始担心别的引用会修改这块数据，破坏我的这块代码的假设。&lt;&#x2F;p&gt;
&lt;p&gt;于是，要想得到数据安全，只需要：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;禁止数据共享: 不允许共享数据 (unsharable)&lt;&#x2F;li&gt;
&lt;li&gt;禁止数据可变: 不允许修改数据 (immutable)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;禁止数据共享。这个好理解，如果这块数据是你独享的，只有你一个引用，那么别的代码不可能对它动手脚，数据是安全的。&lt;&#x2F;p&gt;
&lt;p&gt;禁止数据可变。是函数式的思路，比如 Haskell，不允许有副作用，要想改就基于旧的创建一个新的，数据手递手传递。这样你依赖一个数据，就可以放心地假设它不会被别人悄悄地修改。比如依赖一个字典，可以肯定这个字典的 key-values 不会被悄悄地改掉。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 保护数据安全的机制就是这两个思路的组合：&lt;strong&gt;如果你要允许一个引用修改数据，那么就不允许创建多个引用 (共享数据）。如果你要创建多个引用 (共享数据)，那么就不允许这些引用修改数据。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;简而言之：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;共享不可变，可变不共享&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch04-02-references-and-borrowing.html&quot;&gt;官方文档&lt;&#x2F;a&gt;的说法如下：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;At any given time, you can have either one mutable reference or any number of immutable references.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;（值得注意的是，这是一个静态约束，即编译期的保证）&lt;&#x2F;p&gt;
&lt;p&gt;但凡事总有例外。&lt;&#x2F;p&gt;
&lt;p&gt;有些场景下，这个规则是必须得破坏掉的，否则便实现不了所需要的功能。&lt;&#x2F;p&gt;
&lt;p&gt;比如要实现一个共享 &lt;code&gt;cache&lt;&#x2F;code&gt;，程序的多个地方通过引用指向同一个 &lt;code&gt;cache&lt;&#x2F;code&gt; 对象来使用这个 &lt;code&gt;cache&lt;&#x2F;code&gt;。也就是说，共享 &lt;code&gt;cache&lt;&#x2F;code&gt; 的引用可能有多个（否则就称不上共享了）。&lt;&#x2F;p&gt;
&lt;p&gt;而对一个 &lt;code&gt;cache&lt;&#x2F;code&gt; 的主要使用方式，其实就是读和写。先读一下，如果发现 cache miss，那么就去获取这个 miss 的数据，然后写回 cache。也就是说，&lt;code&gt;cache&lt;&#x2F;code&gt; 的引用必须支持修改数据。&lt;&#x2F;p&gt;
&lt;p&gt;在共享 &lt;code&gt;cache&lt;&#x2F;code&gt; 这个场景下，我们既要能共享数据，又要能修改数据。既要共享性，也要可变性。上文提到的规则不适用了。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 提供了另一个机制来处理这种场景。官方说法叫&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;book&#x2F;ch15-05-interior-mutability.html&quot;&gt;内部可变性(interior-mutability)&lt;&#x2F;a&gt;。其实它的真正意思是：共享可变性(shared-mutability)。&lt;&#x2F;p&gt;
&lt;p&gt;共享可变性在运行期，而不是编译期来保证数据安全。核心做法是使用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;&lt;code&gt;Cell&lt;&#x2F;code&gt; 类型&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;(注：共享可变性是一个极其重要的 pattern，具体可以参考：&lt;a href=&quot;&#x2F;rust-shared-mutability&quot;&gt;深入 Rust - 共享可变性&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;总结一下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Rust 引用有两种：共享性引用(&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;)和可变性引用(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;共享不可变，可变不共享。要么有一个可变性引用(&lt;code&gt;&amp;amp;mut&lt;&#x2F;code&gt;)，要么有任意数量的共享性引用(&lt;code&gt;&amp;amp;&lt;&#x2F;code&gt;)，而不能同时有二者存在。&lt;&#x2F;li&gt;
&lt;li&gt;共享性引用可以使用 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;&lt;code&gt;Cell&lt;&#x2F;code&gt; 类型&lt;&#x2F;a&gt; 使其在运行时可变，以满足共享且可变的场景。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>简明机器学习 - 可微分编程</title>
		<published>2022-10-22T00:00:00+00:00</published>
		<updated>2022-10-22T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/differentiable-programming/" type="text/html"/>
		<id>http://pypy.info/differentiable-programming/</id>
		<content type="html">&lt;p&gt;得到一个程序有两种方式，其一是由程序员来编写它，其二是通过大量数据来拟合它。也就是所谓的编程和机器学习。&lt;&#x2F;p&gt;
&lt;p&gt;当我们在编程的时候，我们是在编写整个程序。当我们在机器学习的时候，我们在编写半个程序，剩下的部分，通过数据来拟合而得。&lt;&#x2F;p&gt;
&lt;p&gt;数据拟合，即通过数据，来反推这个产生这批数据的规律，这个规律相当于代码。&lt;&#x2F;p&gt;
&lt;p&gt;人脑的规则，和数据的规律，融合成一起，成为最终的程序。&lt;&#x2F;p&gt;
&lt;p&gt;现在问题来了，如何通过数据反推规律？&lt;&#x2F;p&gt;
&lt;p&gt;答案就在 “学习” 二字之中。&lt;&#x2F;p&gt;
&lt;p&gt;所谓学习，就是不断尝试，不断犯错，不断调整，直至不出错。&lt;&#x2F;p&gt;
&lt;p&gt;所谓机器学习，就是机器通过不断尝试，不断犯错，不断调整，直至不出错。&lt;&#x2F;p&gt;
&lt;p&gt;这个尝试，反馈，调整的回路，怎么搭建？&lt;&#x2F;p&gt;
&lt;p&gt;对于一个程序，哪些部分需要学习，哪些部分需要硬编码？&lt;&#x2F;p&gt;
&lt;p&gt;让我们从一个常量开始。&lt;&#x2F;p&gt;
&lt;p&gt;比如说，数字 &lt;code&gt;5&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;显然，常量没有任何变化可言，是个硬编码。&lt;&#x2F;p&gt;
&lt;p&gt;现在，我们来让这个常量产生变化的可能性，让它乘以一个变量 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w * 5
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大功告成，世界上最简单的机器学习程序写好了。&lt;code&gt;5&lt;&#x2F;code&gt; 是人编写的，&lt;code&gt;w&lt;&#x2F;code&gt; 是未知的，需要通过机器学习而得到。&lt;&#x2F;p&gt;
&lt;p&gt;下一步，我们需要发明一种机制，来不断调整这个 &lt;code&gt;w&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w = w - dw
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;dw&lt;&#x2F;code&gt; 就是 &lt;code&gt;delta w&lt;&#x2F;code&gt;，也就是 &lt;code&gt;w 的变化&lt;&#x2F;code&gt; 的意思。 &lt;code&gt;w = w - dw&lt;&#x2F;code&gt; 就是调整 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;下一步，我们需要确定这个  &lt;code&gt;dw&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;观察我们的程序 &lt;code&gt;w * 5&lt;&#x2F;code&gt;，它的意思是 &lt;code&gt;w&lt;&#x2F;code&gt; 的任何变化，都会被放大 &lt;code&gt;5&lt;&#x2F;code&gt; 倍。&lt;&#x2F;p&gt;
&lt;p&gt;假如我们把输出记为 &lt;code&gt;y&lt;&#x2F;code&gt;，那么 &lt;code&gt;dy = 5 * dw&lt;&#x2F;code&gt;。即：&lt;code&gt;dw = dy &#x2F; 5&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;有了这个关系，当我们知道了 &lt;code&gt;dy&lt;&#x2F;code&gt;, 就等于知道了 &lt;code&gt;dw&lt;&#x2F;code&gt;，就等于知道了新的 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;那么，如何知道 &lt;code&gt;dy&lt;&#x2F;code&gt;？&lt;&#x2F;p&gt;
&lt;p&gt;既然 &lt;code&gt;y&lt;&#x2F;code&gt; 是我们的输出，那么输出的误差，就是 &lt;code&gt;y&lt;&#x2F;code&gt; 需要调整的变化，即 &lt;code&gt;dy&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;dy = y_guess - y_true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;y_true&lt;&#x2F;code&gt; 就是我们的数据（学习源），&lt;code&gt;y_guess&lt;&#x2F;code&gt; 是一次尝试的输出。&lt;code&gt;y_guess = w * 5&lt;&#x2F;code&gt; ，随 &lt;code&gt;w&lt;&#x2F;code&gt; 的变化而变化。&lt;&#x2F;p&gt;
&lt;p&gt;现在只差最后一步，我们就可以跑通这个流程了。这个最后一步是，&lt;code&gt;w&lt;&#x2F;code&gt; 的初始值怎么设置？&lt;&#x2F;p&gt;
&lt;p&gt;答案很简单，给个随机数就好了，反正它会被自动调节。&lt;&#x2F;p&gt;
&lt;p&gt;现在，我们用真实数据测试一下这个流程：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;# --- test 1 ---
&lt;&#x2F;span&gt;&lt;span&gt;y = 15  # 正确答案, 即 w = 3
&lt;&#x2F;span&gt;&lt;span&gt;w = w0 = 2  # 随机初始化 w 为 2
&lt;&#x2F;span&gt;&lt;span&gt;y_guess = w * 5  # 2 * 5 = 10
&lt;&#x2F;span&gt;&lt;span&gt;dy = y_guess - y  # 10 - 15 = -5
&lt;&#x2F;span&gt;&lt;span&gt;dw = 1&#x2F;5 * dy  # 1&#x2F;5 * -5 = -1
&lt;&#x2F;span&gt;&lt;span&gt;w = w - dw  # 2 - (-1) = 3  &amp;lt;-- w = 3, y = 15 成功学习到 w = 3
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;# --- test 2 ---
&lt;&#x2F;span&gt;&lt;span&gt;y = 40  # 正确答案, 即 w = 8
&lt;&#x2F;span&gt;&lt;span&gt;w = w0 = 12  # 随机初始化 w 为 12
&lt;&#x2F;span&gt;&lt;span&gt;y_guess = w * 5  # 12 * 5 = 60
&lt;&#x2F;span&gt;&lt;span&gt;dy = y_guess - y  # 60 - 40 = 20
&lt;&#x2F;span&gt;&lt;span&gt;dw = 1&#x2F;5 * dy  # 1&#x2F;5 * 20 = 4
&lt;&#x2F;span&gt;&lt;span&gt;w = w - dw  # 12 - 4 = 8  &amp;lt;-- w = 8, y = 40 成功学习到 w = 8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们从一个特例常量 &lt;code&gt;5&lt;&#x2F;code&gt; 开始，通过 &lt;code&gt;w * 5&lt;&#x2F;code&gt; 来推演这个机器学习的过程。其实把常量换成变量 &lt;code&gt;x&lt;&#x2F;code&gt;，上述的推演同样成立，也就是 &lt;code&gt;y = w * x&lt;&#x2F;code&gt;,  因为 &lt;code&gt;w&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;x&lt;&#x2F;code&gt;倍，所以  &lt;code&gt;dy = dw * x&lt;&#x2F;code&gt;,  &lt;code&gt;dw = 1&#x2F;x * d*y&lt;&#x2F;code&gt;。通过特定的的 &lt;code&gt;(x, y)&lt;&#x2F;code&gt; 数据作为学习源，重复上述步骤，可得到正确的 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;现在，我们研究出了怎么把变量和常量参数化，并且通过数据学习这个参数的技术。接下来我们更进一步：既然常量和变量都可以参数化，那么函数可不可以参数化？如果这个函数也是一个需要学习的函数呢？&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;h(x) = w1 * f(x)  # 参数化函数
&lt;&#x2F;span&gt;&lt;span&gt;f(x) = w2 * x  # 参数化变量
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们能同时学习得到 &lt;code&gt;w1&lt;&#x2F;code&gt; 和 &lt;code&gt;w2&lt;&#x2F;code&gt; 吗？&lt;&#x2F;p&gt;
&lt;p&gt;照着刚才的思路，我们需要先考察 &lt;code&gt;dw1&lt;&#x2F;code&gt; 和 &lt;code&gt;dw2&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;对 &lt;code&gt;dw1&lt;&#x2F;code&gt;, 由 &lt;code&gt;w1 * f(x)&lt;&#x2F;code&gt; 可知 &lt;code&gt;w1&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 倍，所以 &lt;code&gt;d_h(x) =  dw1 * f(x)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;对 &lt;code&gt;dw2&lt;&#x2F;code&gt;, 由 &lt;code&gt;w2 * x&lt;&#x2F;code&gt; 可知 &lt;code&gt;w2&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;x&lt;&#x2F;code&gt; 倍，所以 &lt;code&gt;d_f(x) = dw2 * x&lt;&#x2F;code&gt;； 又由 &lt;code&gt;w1 * f(x)&lt;&#x2F;code&gt; 可知，&lt;code&gt;f(x)&lt;&#x2F;code&gt; 的微小变化会被放大 &lt;code&gt;w1&lt;&#x2F;code&gt; 倍，所以 &lt;code&gt;d_h(x)  = d_f(x) * w1&lt;&#x2F;code&gt;。合并起来就是: &lt;code&gt;d_h(x) = d_f(x) * w1 = (dw2 * x) * w1&lt;&#x2F;code&gt; ，所以：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;dw1 = d_h(x) &#x2F; f(x) = d_h(x) &#x2F; (w2 * x)
&lt;&#x2F;span&gt;&lt;span&gt;dw2 = d_h(x) &#x2F; w1 &#x2F; x  # 先除以 w1，再除以 x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们按刚才的思路试一下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;--- 数据
&lt;&#x2F;span&gt;&lt;span&gt;设 w1 = 3, w2 = 6, x = 2, 则 f(x) = 6x, h(x) = 3f(x) = 18x
&lt;&#x2F;span&gt;&lt;span&gt;f(2) = 12, h(2) = 36
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 随机初始化 w1, w2
&lt;&#x2F;span&gt;&lt;span&gt;w1 = 1, w2 = 4
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 调整 10 个循环，结果如下：---
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = -28.0, dw1:-3.5, dw2: -14.0, new w1: 4.5, new w2: 18.0
&lt;&#x2F;span&gt;&lt;span&gt;d_hx = 126.0, dw1:3.5, dw2: 14.0, new w1: 1.0, new w2: 4.0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;显然，我们遇到了新问题：无论如何调整， &lt;code&gt;w1&lt;&#x2F;code&gt; 和 &lt;code&gt;w2&lt;&#x2F;code&gt; 只是在不停地来回震荡，无法学习到正确的值。&lt;&#x2F;p&gt;
&lt;p&gt;问题出在哪里？&lt;&#x2F;p&gt;
&lt;p&gt;问题不在于来回震荡，问题在于震荡幅度每次都一样大，使得这个震荡停不下来。一个钟摆来回摇摆，只要摆动幅度逐渐变小，那么它最终就会停下来。&lt;&#x2F;p&gt;
&lt;p&gt;所以灵感来了，让我们把震荡幅度每次都变小一点。从数学上表达：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w = w - dw * learning_rate
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个 &lt;code&gt;learning_rate&lt;&#x2F;code&gt; 原本是 &lt;code&gt;1&lt;&#x2F;code&gt; 被我们忽略掉了，当我们取一个&lt;code&gt;大于 0 小于 1 &lt;&#x2F;code&gt;的值时，震荡的幅度就会越来越小。&lt;&#x2F;p&gt;
&lt;p&gt;现在，取 &lt;code&gt;learning_rate = 0.6&lt;&#x2F;code&gt; 试试：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;--- 数据
&lt;&#x2F;span&gt;&lt;span&gt;设 w1 = 3, w2 = 6, x = 2, 则 f(x) = 6x, h(x) = 3f(x) = 18x
&lt;&#x2F;span&gt;&lt;span&gt;f(2) = 12, h(2) = 36
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 随机初始化 w1, w2
&lt;&#x2F;span&gt;&lt;span&gt;w1 = 1, w2 = 4
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;--- 调整 10 个循环，结果如下：---
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  8.0000, d_hx = -28.0000, dw1:-3.5000, dw2: -14.0000, new w1:  3.1000, new w2:  12.4000
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  76.8800, d_hx =  40.8800, dw1: 1.6484, dw2:  6.5935, new w1:  2.1110, new w2:  8.4439
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  35.6495, d_hx = -0.3505, dw1:-0.0208, dw2: -0.0830, new w1:  2.1234, new w2:  8.4937
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0713, d_hx =  0.0713, dw1: 0.0042, dw2:  0.0168, new w1:  2.1209, new w2:  8.4836
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  35.9858, d_hx = -0.0142, dw1:-0.0008, dw2: -0.0034, new w1:  2.1214, new w2:  8.4856
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0028, d_hx =  0.0028, dw1: 0.0002, dw2:  0.0007, new w1:  2.1213, new w2:  8.4852
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  35.9994, d_hx = -0.0006, dw1:-0.0000, dw2: -0.0001, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0001, d_hx =  0.0001, dw1: 0.0000, dw2:  0.0000, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0000, d_hx = -0.0000, dw1:-0.0000, dw2: -0.0000, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;span&gt;h(x) =  36.0000, d_hx =  0.0000, dw1: 0.0000, dw2:  0.0000, new w1:  2.1213, new w2:  8.4853
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;成功了吗？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;d_hx&lt;&#x2F;code&gt; 也就是误差的确逐步降低到 0，可是学到的 &lt;code&gt;w1 = 2.1213, w2 = 8.4853&lt;&#x2F;code&gt; ，而我们正确答案是 &lt;code&gt;w1 = 3, w2 = 6&lt;&#x2F;code&gt;。怎么对不上呢？&lt;&#x2F;p&gt;
&lt;p&gt;细心分析下发现， &lt;code&gt;h(x) = w1 * f(x) = w1 * w2 * x  = (w1 * w2) * x&lt;&#x2F;code&gt; ，我们通过 &lt;code&gt;h(x)&lt;&#x2F;code&gt; 的误差来学习整个函数的表示，学到的是一个整体的结果，也就是 &lt;code&gt;w1 * w2&lt;&#x2F;code&gt;，在正确答案中，&lt;code&gt;w1 * w2  = 3 * 6 = 18&lt;&#x2F;code&gt;， 我们的实验结果：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;w1 * w2 = 2.1213 * 8.4853 = 17.9999 ~= 18&lt;&#x2F;code&gt; 也是对的。&lt;&#x2F;p&gt;
&lt;p&gt;也就是说，我们无意中得到了一个因式分解器，因 &lt;code&gt;w1, w2&lt;&#x2F;code&gt; 的初始值不同，我们学习得到不同的参数，这些参数结果对 &lt;code&gt;h(x)&lt;&#x2F;code&gt; 来说，效果都是一样的。有兴趣可以试试。&lt;&#x2F;p&gt;
&lt;p&gt;现在来总结一下机器学习程序的几个要素：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;参数化，使得学习成为可能&lt;&#x2F;li&gt;
&lt;li&gt;计算输出误差，并且根据输出误差反推参数误差&lt;&#x2F;li&gt;
&lt;li&gt;根据参数误差更新参数&lt;&#x2F;li&gt;
&lt;li&gt;重复 1-3 步&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;目前为止我们的探索集中在第一步参数化。其实对于一个机器学习程序来说，哪些部分需要学习（参数化），哪些部分不需要学习（单纯进行数据变换）应该是很自由的事情，否则就编写不出灵活的程序。对于不需要学习，只是单纯做数据变换的部分，我们只需要保证在反推参数误差时，正确地传递这些误差信息就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;说得有些抽象，下面举个例子。比方说：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;h(x) = f(x) ^ 2
&lt;&#x2F;span&gt;&lt;span&gt;f(x) = w * x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;h(x)&lt;&#x2F;code&gt; 是 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 的平方。在这里 &lt;code&gt;h(x)&lt;&#x2F;code&gt; 只是针对 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 的结果做了一个变换（平方），没有任何需要学习的参数。但是，&lt;code&gt;f(x)&lt;&#x2F;code&gt; 是一个需要学习的函数，里边有参数 &lt;code&gt;w&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;要学习 &lt;code&gt;w&lt;&#x2F;code&gt;，我们需要知道 &lt;code&gt;dw&lt;&#x2F;code&gt;；要知道 &lt;code&gt;dw&lt;&#x2F;code&gt;，我们需要知道 &lt;code&gt;d_h(x)&lt;&#x2F;code&gt; 和 &lt;code&gt;dw&lt;&#x2F;code&gt; 的关系。&lt;&#x2F;p&gt;
&lt;p&gt;我们先不着急找这个关系，先来分析一个更加基本的问题。假如有一个函数 &lt;code&gt;y = a * b&lt;&#x2F;code&gt;，&lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 均为变量。那么 &lt;code&gt;dy&lt;&#x2F;code&gt; （y 的变化）其实是由 &lt;code&gt;a&lt;&#x2F;code&gt; 的变化 &lt;code&gt;da&lt;&#x2F;code&gt; ，以及 &lt;code&gt;b&lt;&#x2F;code&gt; 的变化 &lt;code&gt;db&lt;&#x2F;code&gt;所组成。因为 &lt;code&gt;y = a * b&lt;&#x2F;code&gt;，所以 &lt;code&gt;da&lt;&#x2F;code&gt; 会被放大 &lt;code&gt;b&lt;&#x2F;code&gt; 倍贡献到 &lt;code&gt;dy&lt;&#x2F;code&gt;，而 &lt;code&gt;db&lt;&#x2F;code&gt; 会被放大 &lt;code&gt;a&lt;&#x2F;code&gt; 倍贡献到 &lt;code&gt;dy&lt;&#x2F;code&gt;，综合起来就是 &lt;code&gt;dy = a * db + b * da&lt;&#x2F;code&gt;。假如 &lt;code&gt;a = b = x&lt;&#x2F;code&gt;，也就是 &lt;code&gt;y = x * x = x ^ 2&lt;&#x2F;code&gt;， 则有 &lt;code&gt;dy = x * dx + x * dx = 2 * x * dx&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;把 &lt;code&gt;x&lt;&#x2F;code&gt; 替换成 &lt;code&gt;f(x)&lt;&#x2F;code&gt;, 所以：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;d_h(x) = 2 * f(x) * d_f(x)
&lt;&#x2F;span&gt;&lt;span&gt;d_f(x) = dw * x
&lt;&#x2F;span&gt;&lt;span&gt;--&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;dw = d_h(x) &#x2F; (2 * f(x)) &#x2F; x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有了这个关系，代入某个用例验证一下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;待学习：
&lt;&#x2F;span&gt;&lt;span&gt;h(x) = f(x) ^ 2
&lt;&#x2F;span&gt;&lt;span&gt;f(x) = w * x
&lt;&#x2F;span&gt;&lt;span&gt;w = 8
&lt;&#x2F;span&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span&gt;初始化：
&lt;&#x2F;span&gt;&lt;span&gt;w = 2  # 随机
&lt;&#x2F;span&gt;&lt;span&gt;learning_rate = 0.4
&lt;&#x2F;span&gt;&lt;span&gt;---
&lt;&#x2F;span&gt;&lt;span&gt;10 个循环结果：
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 64.0000, out_guess:  4.0000, d_h_x: -60.0000, d_w: -15.0000, w: 17.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 256.0000, out_guess:  1156.0000, d_h_x: 900.0000, d_w: 6.6176, w: 10.3824
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 576.0000, out_guess:  970.1393, d_h_x: 394.1393, d_w: 2.1090, w: 8.2733
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 1024.0000, out_guess:  1095.1677, d_h_x: 71.1677, d_w: 0.2688, w: 8.0045
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 1600.0000, out_guess:  1601.8065, d_h_x: 1.8065, d_w: 0.0045, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 2304.0000, out_guess:  2304.0007, d_h_x: 0.0007, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 3136.0000, out_guess:  3136.0000, d_h_x: 0.0000, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 4096.0000, out_guess:  4096.0000, d_h_x: 0.0000, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;span&gt;out_true: 5184.0000, out_guess:  5184.0000, d_h_x: 0.0000, d_w: 0.0000, w: 8.0000
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Python 代码在&lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;py0x&#x2F;1083a81285505af6775a54ef5c5188f0&quot;&gt;这里&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;最终成功学习到 &lt;code&gt;w = 8&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以总结一下，机器学习的函数和普通编程下的函数有两个不同点：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;可能&lt;&#x2F;strong&gt;带有待学习的参数 w&lt;&#x2F;li&gt;
&lt;li&gt;除了能够正向计算结果，还需要反向计算误差（为了调整参数）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;只要我们的函数都满足这两点，并且能够这些函数组合起来，就能得到一个能够学习的程序。&lt;&#x2F;p&gt;
&lt;p&gt;下面，我们来研究函数组合的问题。&lt;&#x2F;p&gt;
&lt;p&gt;最简单的组合方式是：一个函数的输出是另一个函数的输入。这种情况我们已经通过上文的 &lt;code&gt;h(x)&lt;&#x2F;code&gt;  和 &lt;code&gt;f(x)&lt;&#x2F;code&gt; 无意中研究过。&lt;&#x2F;p&gt;
&lt;p&gt;在编程视角下，更基本的组合方式是 &lt;code&gt;if ... else ...&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;问题是这种逻辑控制语句，怎么计算和传播误差？&lt;&#x2F;p&gt;
&lt;p&gt;首先，我们需要把它表示出来。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;if p(x):
&lt;&#x2F;span&gt;&lt;span&gt;    return f(x)
&lt;&#x2F;span&gt;&lt;span&gt;else:
&lt;&#x2F;span&gt;&lt;span&gt;    return h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后进行数学化。&lt;&#x2F;p&gt;
&lt;p&gt;非此即彼的 &lt;code&gt;if else&lt;&#x2F;code&gt;，在数学上，其实是 1 和 0.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;1 * f(x) + 0 * h(x)&lt;&#x2F;code&gt; 就是 &lt;code&gt;f(x)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;0 * f(x) + 1 * h(x)&lt;&#x2F;code&gt; 就是 &lt;code&gt;h(x)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这个 &lt;code&gt;1&lt;&#x2F;code&gt; 和 &lt;code&gt;0&lt;&#x2F;code&gt; 的逻辑关系需要学习出来，其实就是变成参数：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w1 * f(x) + w2 * h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;接下来的问题是，&lt;code&gt;p(x)&lt;&#x2F;code&gt; 怎么和它们关联起来？&lt;&#x2F;p&gt;
&lt;p&gt;其实细细想一下，这个 &lt;code&gt;w1&lt;&#x2F;code&gt; 和 &lt;code&gt;w2&lt;&#x2F;code&gt; 正是 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出结果。而且 &lt;code&gt;w2 = 1 - w1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;于是我们只要保证 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出范围在 &lt;code&gt;0 ~ 1&lt;&#x2F;code&gt;，那么有：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w = p(x)
&lt;&#x2F;span&gt;&lt;span&gt;output = w * f(x) + (1 - w) * h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里需要注意的是，&lt;code&gt;w&lt;&#x2F;code&gt; 并不是直接学习得到的参数，而是 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出结果，我们并不是直接学习 &lt;code&gt;w&lt;&#x2F;code&gt;，而是学习一个 &lt;code&gt;p(x)&lt;&#x2F;code&gt; ，也就是学习 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 内部的参数。为了不容易混淆，我把它换成 &lt;code&gt;k&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;k = p(x)
&lt;&#x2F;span&gt;&lt;span&gt;output = k * f(x) + (1 - k) * h(x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大功接近告成。剩下的问题是怎么保证 &lt;code&gt;p(x)&lt;&#x2F;code&gt; 的输出落在 0 至 1 之间。&lt;&#x2F;p&gt;
&lt;p&gt;很简单，套上一个值域在 0 至 1 之间的变换函数即可。&lt;&#x2F;p&gt;
&lt;p&gt;这种函数有很多，比如可以自己构造一个 &lt;code&gt;1 &#x2F; (1 + f(x) ^ 2)&lt;&#x2F;code&gt;。(这个函数的误差怎么反向传播，可以自己试试）&lt;&#x2F;p&gt;
&lt;p&gt;至此，我们有了可以学习的 &lt;code&gt;if ... else ...&lt;&#x2F;code&gt; 控制语句。&lt;&#x2F;p&gt;
&lt;p&gt;有了这个思路，其实查字典也可以数学化表示。&lt;&#x2F;p&gt;
&lt;p&gt;一个字典，其实是 &lt;code&gt;{k, v}&lt;&#x2F;code&gt; 容器，查字典就是有一个 &lt;code&gt;q&lt;&#x2F;code&gt;, 当 &lt;code&gt;q == k&lt;&#x2F;code&gt; 时，返回对应的 &lt;code&gt;v&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在机器学习的世界里，&lt;code&gt;(q, k, v)&lt;&#x2F;code&gt; 都是数字。&lt;&#x2F;p&gt;
&lt;p&gt;判断 &lt;code&gt;q == k&lt;&#x2F;code&gt; 的操作，表达为 &lt;code&gt;q&lt;&#x2F;code&gt; 和 &lt;code&gt;k&lt;&#x2F;code&gt; 的差别，比如说 &lt;code&gt;q - k&lt;&#x2F;code&gt; 的大小。于是有：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;d1 = q - k1
&lt;&#x2F;span&gt;&lt;span&gt;d2 = q - k2
&lt;&#x2F;span&gt;&lt;span&gt;d3 = q - k3
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后把 &lt;code&gt;d1, d2, d3 ...&lt;&#x2F;code&gt; 进行归一化操作。再把归一化后的结果作为权重 &lt;code&gt;w&lt;&#x2F;code&gt;，去提取 &lt;code&gt;v&lt;&#x2F;code&gt;，也就是 &lt;code&gt;(1-w) * v&lt;&#x2F;code&gt; (需要用 &lt;code&gt;1 - w&lt;&#x2F;code&gt; 是因为差异越小，提取权重越大）。&lt;&#x2F;p&gt;
&lt;p&gt;归一化比较简单的方式是: &lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;w1 = d1 &#x2F; (d1 + d2 + d3 + ... + dn)
&lt;&#x2F;span&gt;&lt;span&gt;w2 = d2 &#x2F; (d1 + d2 + d3 + ... + dn)
&lt;&#x2F;span&gt;&lt;span&gt;w3 = d3 &#x2F; (d1 + d2 + d3 + ... + dn)
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们现在可以总结一下：&lt;&#x2F;p&gt;
&lt;p&gt;要使得一个程序能够变成机器学习程序，思路是把所有的操作变成数学公式表达，这个数学公式需要能够反向计算出误差是怎么传播的。&lt;&#x2F;p&gt;
&lt;p&gt;范式如下：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;输入输出数据转换成数字&lt;&#x2F;li&gt;
&lt;li&gt;控制操作转换成数学公式&lt;&#x2F;li&gt;
&lt;li&gt;正向计算结果和误差&lt;&#x2F;li&gt;
&lt;li&gt;反向根据误差更新参数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在机器学习的世界中，一个操作既能正向计算结果，也能反向传播误差并更新参数。当我们把常用的操作封装起来，然后提供一些能组合这些操作的胶水操作，用户就可以像搭积木一样利用我们提供的操作原语 (primitive) 来搭建一个可以学习的程序，这个程序因为参数是未知的，而架构是已知的，所以叫模型。这个行为就是所谓的机器学习建模。&lt;&#x2F;p&gt;
&lt;p&gt;搭建好的模型，通过大量灌入数据，调整模型参数，就是所谓机器学习训练。&lt;&#x2F;p&gt;
&lt;p&gt;而本文提到的这种编程范式，有一个正式的名字，叫可微分编程。可微分，指的是这个数学操作可微，使得误差可以反向传播，从而使程序可以自我学习。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;后记：&lt;&#x2F;p&gt;
&lt;p&gt;关于机器学习，网上有大量优秀的文章和教程。我尝试补充一个更基础且具有启发性的角度。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>简明 Rust - 理解 Rust Ownership 机制</title>
		<published>2022-09-24T00:00:00+00:00</published>
		<updated>2022-09-24T00:00:00+00:00</updated>
		<link rel="alternate" href="http://pypy.info/rust-ownership/" type="text/html"/>
		<id>http://pypy.info/rust-ownership/</id>
		<content type="html">&lt;p&gt;每个编程语言都有自己管理内存的方式。因为内存有限，原则是数据在使用的时候加载到内存，不需要使用的时候及时释放，避免内存被撑爆。&lt;&#x2F;p&gt;
&lt;p&gt;较底层的语言比如 &lt;code&gt;C&lt;&#x2F;code&gt;  ，需要程序员手动管理内存。也就是手动申请内存，手动释放内存。&lt;&#x2F;p&gt;
&lt;p&gt;较高级的语言比如 &lt;code&gt;Python&lt;&#x2F;code&gt; ，有所谓垃圾回收机制，无需用户手动管理内存，大为减轻程序员心智负担。&lt;&#x2F;p&gt;
&lt;p&gt;而 &lt;code&gt;Rust&lt;&#x2F;code&gt; 比较独特，采用了一种叫 &lt;code&gt;Ownership&lt;&#x2F;code&gt; 的机制来管理内存。可以认为是一种半自动的内存管理方式。&lt;&#x2F;p&gt;
&lt;p&gt;据说有不少程序员在理解 &lt;code&gt;Ownership&lt;&#x2F;code&gt; 机制时会遇到困难，其中不乏经验丰富的程序员。&lt;&#x2F;p&gt;
&lt;p&gt;经验告诉我们，理解新事物出现困难，往往是成见太深。也就是说只要放轻松，回归到事情的原点来看待问题，就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;假如现在要实现一个自动管理内存的机制，比较自然的思路是看看这块内存有谁在使用，如果没有被使用，则表明这块内存可以被回收以便再次使用。这个思路大家称之为&lt;code&gt;引用计数法&lt;&#x2F;code&gt;，即当引用数为 0 时，可回收内存。比如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Data&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;b = a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此时，对数据 &lt;code&gt;Data()&lt;&#x2F;code&gt; 所占用的内存，有 &lt;code&gt;2&lt;&#x2F;code&gt; 个引用，分别是 &lt;code&gt;a&lt;&#x2F;code&gt;  和 &lt;code&gt;b&lt;&#x2F;code&gt;  。当 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 这两个变量退出作用域，那么数据 &lt;code&gt;Data&lt;&#x2F;code&gt; 所占用的内存引用数为 &lt;code&gt;0&lt;&#x2F;code&gt;，可以在恰当的时候被回收。(所谓变量退出作用域，大意是变量所在的作用域 (scope) 被关闭，比如函数返回)。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;引用计数&lt;&#x2F;code&gt;这种行为会给程序带来额外的开销，因为运行时 (runtime) 需要一直去追踪每份数据到底有多少引用，并且对引用数为 0 的数据定时执行释放。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 的思路是既然引用计数会带来额外开销，那就干脆不计数了。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用数永远为 1，可不可以？&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;回到刚才的例子，&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span&gt;a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Data&lt;&#x2F;span&gt;&lt;span&gt;()  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 引用数 = 1 ，引用为 a 
&lt;&#x2F;span&gt;&lt;span&gt;b = a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 引用数 = 1 ，引用为 b， 且 a 不再合法 
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在 &lt;code&gt;b = a&lt;&#x2F;code&gt; 之后，&lt;code&gt;a&lt;&#x2F;code&gt; 不能再使用，因为引用数只能为 1，且对 &lt;code&gt;Data()&lt;&#x2F;code&gt; 的引用变成了 &lt;code&gt;b&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;直观一点来看这个规则，&lt;code&gt;Data()&lt;&#x2F;code&gt; 就像有了一个 &lt;code&gt;owner&lt;&#x2F;code&gt; 一样，&lt;code&gt;a = Data()&lt;&#x2F;code&gt; 时，&lt;code&gt;owner&lt;&#x2F;code&gt; 是 &lt;code&gt;a&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;b = a&lt;&#x2F;code&gt; 后，&lt;code&gt;owner&lt;&#x2F;code&gt; 从 &lt;code&gt;a&lt;&#x2F;code&gt; 变成了 &lt;code&gt;b&lt;&#x2F;code&gt;，就像 &lt;code&gt;Data()&lt;&#x2F;code&gt; 从 &lt;code&gt;a&lt;&#x2F;code&gt; 转移 (move) 到了 &lt;code&gt;b&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;有了这个规则之后，内存回收就变得简单了，当 &lt;code&gt;owner&lt;&#x2F;code&gt; 退出作用域时 (scope 关闭)，就可以回收内存。&lt;&#x2F;p&gt;
&lt;p&gt;我认为，在写 &lt;code&gt;Rust&lt;&#x2F;code&gt; 程序的时候，保持一种&lt;strong&gt;数据在不同的变量之间移来移去&lt;&#x2F;strong&gt;的感觉是非常有帮助的。&lt;&#x2F;p&gt;
&lt;p&gt;然而，问题还没完全解决。现实是复杂的，某些情况下，引用数就是需要有多个，不可能为 1。&lt;&#x2F;p&gt;
&lt;p&gt;怎么办？&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用计数啊！&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 的意思是，只有在需要的时候，才使用引用计数。&lt;code&gt;Rust&lt;&#x2F;code&gt; 提供了 &lt;code&gt;Rc&lt;&#x2F;code&gt; 和 &lt;code&gt;Arc&lt;&#x2F;code&gt; 两种 wrapper 来启用引用计数功能 (&lt;code&gt;Arc&lt;&#x2F;code&gt; 是线程安全版本的 &lt;code&gt;Rc&lt;&#x2F;code&gt;)。上面的例子可以写为:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; a = Rc::new(Data::new());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; b = a.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这时候，当 &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 都不再使用时，&lt;code&gt;Data&lt;&#x2F;code&gt; 才会被销毁。&lt;&#x2F;p&gt;
&lt;p&gt;引用计数的使用场景在并发共享数据的情况下极为常见，比如要开 &lt;code&gt;n&lt;&#x2F;code&gt; 个线程同时访问同一份数据，这时候便需要用 &lt;code&gt;Arc&lt;&#x2F;code&gt; 把数据包装起来，然后 &lt;code&gt;.clone()&lt;&#x2F;code&gt;  &lt;code&gt;n&lt;&#x2F;code&gt; 次得到 &lt;code&gt;n&lt;&#x2F;code&gt; 个 owner，再 move 到线程里边使用。大概的模式如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; n = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data = Arc::new(Data::new());  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;开启引用计数
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;..n {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data_x = data.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clone&lt;&#x2F;span&gt;&lt;span&gt;();  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 先 clone 一个 owner
&lt;&#x2F;span&gt;&lt;span&gt;    thread::spawn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;move &lt;&#x2F;span&gt;&lt;span&gt;|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;do_something&lt;&#x2F;span&gt;&lt;span&gt;(data_x);  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 将 data_x move 到线程内使用 
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有了 &lt;code&gt;Rc&lt;&#x2F;code&gt; 和 &lt;code&gt;Arc&lt;&#x2F;code&gt;， 问题似乎得到了完美的解决。&lt;&#x2F;p&gt;
&lt;p&gt;但是，这样做似乎很麻烦。因为多引用是一个极为常见的情况。有没有别的办法？&lt;&#x2F;p&gt;
&lt;p&gt;引用计数，引用计数。能不能只引用，不计数？&lt;&#x2F;p&gt;
&lt;p&gt;关键就在这里。引用之所以需要计数，是因为引用的新增和销毁行为是动态的，也就是说需要把程序跑起来才能知道，所以才需要一个动态的计数器来追踪这个动态的行为。&lt;&#x2F;p&gt;
&lt;p&gt;反过来，如果引用的新增和销毁行为是静态的，也就是编译期就能知道，那么就不需要计数了。&lt;&#x2F;p&gt;
&lt;p&gt;比如有数据引用 a，此后从 a 衍生出新引用 &amp;amp;a，且静态分析得知 &amp;amp;a 使用并销毁在 a 销毁之前，那么数据就可以只增加引用而不增加计数，因为从内存回收的角度，这个 &amp;amp;a 的引用实际上就像没出现过一样。&lt;&#x2F;p&gt;
&lt;p&gt;也就是说，编译时确保 &amp;amp;a 的生命周期在 a 的生命周期以内，那么运行时只需要在 a 销毁的时候回收内存即可。&lt;&#x2F;p&gt;
&lt;p&gt;直观感受一下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;textile&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-textile &quot;&gt;&lt;code class=&quot;language-textile&quot; data-lang=&quot;textile&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    a = Data()
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        b = &amp;amp;a  &#x2F;&#x2F; &amp;amp;a started
&lt;&#x2F;span&gt;&lt;span&gt;        ... do something ...
&lt;&#x2F;span&gt;&lt;span&gt;    }  &#x2F;&#x2F; &amp;amp;a ended
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这就是 &lt;code&gt;Rust&lt;&#x2F;code&gt; 所谓的 &lt;code&gt;Borrow&lt;&#x2F;code&gt; 和 &lt;code&gt;Lifetime&lt;&#x2F;code&gt; 的概念。&lt;&#x2F;p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;Borrow&lt;&#x2F;code&gt; 和 &lt;code&gt;Lifetime&lt;&#x2F;code&gt; 需要依赖编译期的静态分析，所以往往适用于顺序执行的情况。而在并发执行时，因为往往不知道哪个并发单元先执行完，需要使用动态的 &lt;code&gt;Arc&lt;&#x2F;code&gt; 来进行引用计数。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;总结：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ownership&lt;&#x2F;code&gt; 机制是一种特殊的引用计数内存管理机制，计数永远为 1 。在写 &lt;code&gt;Rust&lt;&#x2F;code&gt; 程序的时候，保持一种&lt;strong&gt;数据在不同的变量之间移来移去&lt;&#x2F;strong&gt;的感觉是非常有帮助的.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Rust&lt;&#x2F;code&gt; 同样支持常规的引用计数内存管理机制，&lt;code&gt;Rc&#x2F;Arc&lt;&#x2F;code&gt;。在并发编程的时候经常会用到。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;此外，&lt;code&gt;Rust&lt;&#x2F;code&gt; 支持只增加引用不增加计数的机制，也就是 &lt;code&gt;Borrow&lt;&#x2F;code&gt;。这种机制需要依赖编译期的静态分析，以确保 &lt;code&gt;Lifetime&lt;&#x2F;code&gt; 的合法。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;严谨的细节和规范看文档就可以，带着上面的思路多写写，很容易找到感觉。&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
